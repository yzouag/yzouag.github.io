<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="https://yzouag.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://yzouag.github.io/" rel="alternate" type="text/html" /><updated>2022-02-08T06:23:25+00:00</updated><id>https://yzouag.github.io/feed.xml</id><title type="html">Wilson ZOU’s Home Page</title><subtitle>This is my personal homepage, and I will share my thoughts and projects here!</subtitle><author><name>Wilson ZOU</name></author><entry><title type="html">HKUST COMP4901U Computer Language Processing and Compiler Design</title><link href="https://yzouag.github.io/cs/complier_design/" rel="alternate" type="text/html" title="HKUST COMP4901U Computer Language Processing and Compiler Design" /><published>2022-01-03T00:00:00+00:00</published><updated>2022-01-03T00:00:00+00:00</updated><id>https://yzouag.github.io/cs/complier_design</id><content type="html" xml:base="https://yzouag.github.io/cs/complier_design/"><![CDATA[<h2 id="introduction">introduction</h2>

<ul>
  <li>
    <p>a <strong>language</strong> can be natural language, computer language, language of mathematics</p>

    <p><img src="/assets/images/compiler/p1.png" alt="" /></p>
  </li>
  <li>
    <p>processing general-purpose programming languages:</p>

    <ul>
      <li>interpreter: execute instructions while traversing the program (Python)</li>
      <li>compiler: traverse program, generate executable code to run later (Rust, C)</li>
    </ul>
  </li>
  <li>
    <p>general compiler organization</p>

    <p><img src="/assets/images/compiler/p2.png" alt="" /></p>

    <ul>
      <li>source code: for programmers, higher level for abstraction and productiveness</li>
      <li>target code: efficiently run on hardware, low level</li>
    </ul>
  </li>
  <li>
    <p>front end &amp; back end in compiler</p>

    <p>front-end —————————————————————————–&gt; back-end</p>

    <p>lexical analyzer -&gt; parser -&gt; name analyzer -&gt; type checker -&gt; intermediate code generator -&gt; JIT compiler or platform-specific back end</p>
  </li>
  <li>
    <p>program first to a tree structure, <strong>Abstract Syntax Tree (AST)</strong></p>

    <ul>
      <li>node represents arithmetic operations, statements, blocks</li>
      <li>leaves represent constants, variables, methods</li>
    </ul>
  </li>
</ul>

<h2 id="theory-of-formal-languages">theory of formal languages</h2>

<h3 id="word">word</h3>

<h4 id="define-of-word">define of word</h4>

<p>Let A be an <strong>alphabet</strong> {a, b, c, …}</p>

<p>define words of length n, as A^n^, as follow:</p>

<ul>
  <li>A^0^ = ${\epsilon}$, only one word of length 0</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>For n &gt; 0, $A^n = {aw</td>
          <td>w\in A^{n-1}}$</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<p>set of all words: $A^* = \cup_{n \ge 0}A^n$</p>

<h4 id="equivalent-word">equivalent word</h4>

<p>Let $u,v \in A^*$, then u=v if and only if</p>

<ol>
  <li>$u=\epsilon \text{ and } v = \epsilon$; or</li>
  <li>$u=au^\prime ~ and ~ v = av^\prime ~ where ~ u^\prime = v^\prime$</li>
</ol>

<h4 id="theorem-structural-induction-of-words">Theorem (Structural induction of words)</h4>

<p>$P(\epsilon)$ , P(u) implies P(au), then for any word a, P(a) is correct</p>

<h4 id="word-concatenation">word concatenation</h4>

<p>$ u \cdot v = \left{ 
  \begin{array}{ c l }
    v &amp;  \text{if } u=\epsilon <br />
    a(u^\prime \cdot v) &amp;  \text{if } u = au^\prime
  \end{array}
\right. $</p>

<p>for easy notation, uv means word concatenation</p>

<p><img src="/assets/images/compiler/p3.png" alt="" /></p>

<h4 id="free-monoid-of-words">free monoid of words</h4>

<p>an algebraic structure, word monoid satisfies two additional properties:</p>

<ul>
  <li>left cancellation law, if wu = wv, then u = v</li>
  <li>right cancellation law</li>
</ul>

<h4 id="reversal">reversal</h4>

<p><img src="/assets/images/compiler/p4.png" alt="" /></p>

<h4 id="prefix-suffix-and-slice">prefix, suffix, and slice</h4>

<p>easy as name extends</p>

<h3 id="language">language</h3>

<h4 id="define-of-language">define of language</h4>

<p>a language over alphabet A is a set $L \subseteq A^\prime$, for example A = {0, 1}</p>

<ul>
  <li>a finite language like L={0, 1, 01, 010}, or the empty language $\empty$</li>
  <li>infinite but very difficult to describe</li>
  <li>infinite but having some nice structure, a pattern for description precisely</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>for example, $L_2=\set{01, 0101, 010101, …} = \set{(01)^n</td>
      <td>n\ge1}$</td>
    </tr>
  </tbody>
</table>

<p>language is a set, we have union, intersection, and other set operations</p>

<h4 id="language-operations">language operations</h4>

<p><img src="/assets/images/compiler/p5.png" alt="" /></p>

<p><img src="/assets/images/compiler/p6.png" alt="" /></p>

<h4 id="monoid-of-language">monoid of language</h4>

<p>two conditions for monoid</p>

<ul>
  <li>a neutral element, $L\set{\epsilon}=L,\set{\epsilon}L=L, \text{ so } \set{\epsilon}$ is one</li>
  <li>associative law: we need $L_1 \cdot (L_2 \cdot L_3)=(L_1 \cdot L_2) \cdot L_3$</li>
</ul>

<p><img src="/assets/images/compiler\Snipaste_2021-12-09_22-17-51.png" style="zoom:50%; float: left" /></p>

<p>note: no cancellation law! $L_1\empty = \empty = L_2 \empty$ but not necessarily L1=L2</p>

<h4 id="represent-programming-language">represent programming language</h4>

<p>in general, some formal languages are not <strong><em>recursively enumerable sets</em></strong></p>

<p>a language $L \subseteq A^<em>$ is given by its <strong>characteristic function</strong> $f_L : A^</em>\to \set{0,1}$, defined by f~L~(w) = 1 for w in L, and 0 for w not in L</p>

<table>
  <tbody>
    <tr>
      <td>for example, for $L_2=\set{01, 0101, 010101, …} = \set{(01)^n</td>
      <td>n\ge1}$</td>
    </tr>
  </tbody>
</table>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="o">(</span><span class="n">w</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">w</span> <span class="k">match</span>
    <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">()))</span> <span class="k">=&gt;</span> <span class="kc">true</span>
    <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">wRest</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">wRest</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>

<span class="k">val</span> <span class="nv">L2</span> <span class="k">=</span> <span class="nc">Lang</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
<span class="nv">L2</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="mi">0</span><span class="o">::</span><span class="mi">1</span><span class="o">::</span><span class="mi">0</span><span class="o">::</span><span class="mi">1</span><span class="o">::</span><span class="nc">Nil</span><span class="o">())</span> <span class="c1">// true</span>
</code></pre></div></div>

<h4 id="kleene-star-repetition-of-a-language">Kleene Star, repetition of a language</h4>

<p><img src="/assets/images/compiler\Snipaste_2021-12-09_22-38-30.png" alt="" /></p>

<h2 id="regular-expression">regular expression</h2>

<p>one way to denote (often infinite) languages</p>

<h4 id="definition">definition</h4>

<p>a regular expression e is built from:</p>

<ul>
  <li>$\empty$, corresponds to the empty language</li>
  <li>$\epsilon$, corresponding to $\set{\epsilon}$</li>
  <li>a, b, etc. corresponding to $\set{a}, \set{b},…$</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>e1</td>
          <td>e2 corresponding to $L_{e1} \cup L_{e2}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>e1e2, corresponding to $L_{e1} \cdot L_{e2}$</li>
  <li>e* corresponding to $L_{e}^{*}$</li>
</ul>

<h4 id="regular-expression-operators">regular expression operators</h4>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>[a…z] = a</td>
          <td>b</td>
          <td>…</td>
          <td>z</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>e^?^ = e</td>
          <td>$\epsilon$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>e^+^ = e e^*^</li>
  <li>e^k..<em>^ = e^k^ e^</em>^ and e^p..q^ = e^p^ (e^?^)^q-p^</li>
  <li>!e, complementary, no obvious translation from base oprators</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>e1 &amp; e2 = ! (!e1</td>
          <td>!e2), denoting $L_{e1} \cap L_{e2}$</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="properties-of-regular-expression">properties of regular expression</h4>

<p>emptiness, inclusion, disjointness</p>

<h2 id="lexical-analysis">lexical Analysis</h2>

<p>input: character streams. res = 14 + arg * 3</p>

<p>output: token streams. “res”, “=”, “14”, “+”, “arg”, “*”, “3”</p>

<p>key ideas:</p>

<ul>
  <li>small memory usage</li>
  <li>not difficult to construct manually</li>
  <li>use longest match rule</li>
</ul>

<p>lexer is implemented by:</p>

<ul>
  <li>conversion to finite-state automata</li>
  <li>usage of regular expression derivation</li>
</ul>

<h4 id="example-of-a-simple-lexer">example of a simple lexer:</h4>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num</span> <span class="k">=</span> <span class="mi">13</span><span class="o">;</span> 
<span class="nf">while</span> <span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> 
  <span class="nf">println</span><span class="o">(</span><span class="s">"num = "</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span> 
  <span class="nf">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> 
    <span class="n">num</span> <span class="k">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> 
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> 
    <span class="n">num</span> <span class="k">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> 
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>tokens:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Ident</span> <span class="o">::=</span>
	<span class="nf">letter</span> <span class="o">(</span><span class="n">letter</span> <span class="o">|</span> <span class="n">digit</span><span class="o">)*</span>
<span class="n">integerConst</span> <span class="o">::=</span>
	<span class="n">digit</span> <span class="n">digit</span><span class="o">*</span>
<span class="n">keywords</span>
	<span class="k">if</span>  <span class="k">else</span>  <span class="k">while</span>  <span class="n">println</span>
<span class="n">special</span> <span class="nf">symbols</span>
	<span class="o">(</span>  <span class="o">)</span>   <span class="o">&amp;&amp;</span>  <span class="o">&lt;</span>   <span class="o">==</span>  <span class="o">+</span>  <span class="o">-</span>  <span class="o">*</span>  <span class="o">/</span>  <span class="o">%</span>  <span class="o">!</span>  <span class="o">-</span> <span class="o">{</span>  <span class="o">}</span>  <span class="o">;</span>  <span class="o">,</span>  
<span class="n">letter</span> <span class="o">::=</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="o">|</span> <span class="n">c</span> <span class="o">|</span> <span class="err">…</span> <span class="o">|</span> <span class="n">z</span> <span class="o">|</span> <span class="n">A</span> <span class="o">|</span> <span class="n">B</span> <span class="o">|</span> <span class="n">C</span> <span class="o">|</span> <span class="err">…</span> <span class="o">|</span> <span class="n">Z</span>
<span class="n">digit</span> <span class="o">::=</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="err">…</span> <span class="o">|</span> <span class="mi">8</span> <span class="o">|</span> <span class="mi">9</span>
</code></pre></div></div>

<p>a small hand-written lexer:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">enum</span> <span class="nc">Token</span><span class="k">:</span>
    <span class="kt">case</span> <span class="kt">ID</span><span class="o">(</span><span class="kt">content:</span> <span class="kt">String</span><span class="o">)</span> <span class="c1">// id3</span>
    <span class="k">case</span> <span class="nc">IntConst</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="c1">// 10</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">AssignEQ</span>
    <span class="k">case</span> <span class="nc">CompareEQ</span>
    <span class="k">case</span> <span class="nc">MUL</span> <span class="c1">// *</span>
    <span class="k">case</span> <span class="nc">PLUS</span> <span class="c1">// +</span>
    <span class="k">case</span> <span class="nc">LEQ</span> <span class="c1">// &lt;=</span>
    <span class="k">case</span> <span class="nc">OPAREN</span>
    <span class="k">case</span> <span class="nc">CPAREN</span>
    <span class="k">case</span> <span class="nc">IF</span>
    <span class="k">case</span> <span class="nc">WHILE</span>
    <span class="k">case</span> <span class="nc">EOF</span> <span class="c1">// End Of File</span>

<span class="k">class</span> <span class="nc">CharStream</span><span class="o">(</span><span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span>
    <span class="kt">val</span> <span class="kt">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span>
    <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">fileName</span><span class="o">))</span>
    <span class="k">var</span> <span class="n">current</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="o">'\</span><span class="mh">0x0</span><span class="o">'</span>
    <span class="k">var</span> <span class="n">eof</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="k">def</span> <span class="nf">next</span> <span class="k">=</span>
    	<span class="nf">if</span> <span class="o">(</span><span class="n">eof</span><span class="o">)</span> 
			<span class="k">throw</span> <span class="nc">EndOfInput</span><span class="o">(</span><span class="s">"reading"</span> <span class="o">+</span> <span class="n">file</span><span class="o">)</span>
    	<span class="k">val</span> <span class="nv">c</span> <span class="k">=</span> <span class="nv">file</span><span class="o">.</span><span class="py">read</span><span class="o">()</span>
    	<span class="n">eof</span> <span class="k">=</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    	<span class="n">current</span> <span class="k">=</span> <span class="nv">c</span><span class="o">.</span><span class="py">toChar</span>
    <span class="n">next</span> <span class="c1">// initialize first char</span>

<span class="k">class</span> <span class="nc">Lexer</span><span class="o">(</span><span class="n">ch</span><span class="k">:</span> <span class="kt">CharStream</span><span class="o">)</span><span class="k">:</span>
    <span class="kt">var</span> <span class="kt">current:</span> <span class="kt">Token</span>
    <span class="k">def</span> <span class="nf">next</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
		<span class="c1">// lexer code goes here</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">isLetter</span><span class="o">)</span> <span class="o">{</span>
  			<span class="n">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span>
            <span class="nf">while</span> <span class="o">(</span><span class="n">isLetter</span> <span class="o">||</span> <span class="n">isDigit</span><span class="o">)</span> <span class="o">{</span>
                <span class="nv">b</span><span class="o">.</span><span class="py">append</span><span class="o">(</span><span class="nv">ch</span><span class="o">.</span><span class="py">current</span><span class="o">)</span>
                <span class="nv">ch</span><span class="o">.</span><span class="py">next</span>
            <span class="o">}</span>
 			<span class="nv">keywords</span><span class="o">.</span><span class="py">lookup</span><span class="o">(</span><span class="nv">b</span><span class="o">.</span><span class="py">toString</span><span class="o">)</span> <span class="o">{</span> 
  				<span class="k">case</span> <span class="nc">None</span><span class="k">=&gt;</span> <span class="n">token</span><span class="k">=</span><span class="nc">ID</span><span class="o">(</span><span class="nv">b</span><span class="o">.</span><span class="py">toString</span><span class="o">)</span>
  				<span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">kw</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">token</span><span class="k">=</span><span class="n">kw</span>
 			<span class="o">}</span>
		<span class="o">}</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">isDigit</span><span class="o">)</span> <span class="o">{</span>
  			<span class="n">k</span> <span class="k">=</span> <span class="mi">0</span>
  			<span class="nf">while</span> <span class="o">(</span><span class="n">isDigit</span><span class="o">)</span> <span class="o">{</span>
    			<span class="n">k</span> <span class="k">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">k</span> <span class="o">+</span> <span class="nf">toDigit</span><span class="o">(</span><span class="nv">ch</span><span class="o">.</span><span class="py">current</span><span class="o">)</span>
    			<span class="nv">ch</span><span class="o">.</span><span class="py">next</span>
  			<span class="o">}</span>
  			<span class="n">token</span> <span class="k">=</span> <span class="nc">IntConst</span><span class="o">(</span><span class="n">k</span><span class="o">)</span>
		<span class="o">}</span>
</code></pre></div></div>

<h4 id="deciding-which-token-is-coming">deciding which token is coming</h4>

<p>problem: how do we know we are analyzing a string or integer sequence?</p>

<h5 id="first">first</h5>

<p>use first(e) - symbols with which e can start</p>

<p>$first(L) = \set{a \in A \mid \exist v \in A^*. ~ av\in L }$</p>

<p>example: L = {a, ab}, first(L) = {a}</p>

<p>​	first($\empty$) = $\empty$</p>

<p>​	first($\epsilon$) = $\empty$</p>

<p>​	first(a) = {a}</p>

<table>
  <tbody>
    <tr>
      <td>​	first(e1</td>
      <td>e2) = first(e1) $\cup$ first(e2)</td>
    </tr>
  </tbody>
</table>

<p>​	first(e^*^) = first(e)</p>

<p>​	first(e1e2) = $\text{if }(nullable(e1))\text{ then }first(e1) \cup first(e2) \text{ else } first(e1)$</p>

<h5 id="nullable">nullable</h5>

<p>​	nullable($\empty$) = false</p>

<p>​	nullable($\epsilon$) = true</p>

<p>​	nullable(a) = false</p>

<table>
  <tbody>
    <tr>
      <td>​	nullable(e1</td>
      <td>e2) = nullable(e1) $\or$ nullable(e2)</td>
    </tr>
  </tbody>
</table>

<p>​	nullable(e^*^) = true</p>

<p>​	nullable(e1e2) = nullable(e1) $\and$ nullable(e2)</p>

<p><img src="/assets/images/compiler\Snipaste_2021-12-09_23-52-54.png" style="zoom:50%;" /></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">ch</span><span class="o">.</span><span class="py">current</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="sc">'('</span> <span class="k">=&gt;</span> <span class="o">{</span><span class="n">current</span> <span class="k">=</span> <span class="nc">OPAREN</span><span class="o">;</span> <span class="nv">ch</span><span class="o">.</span><span class="py">next</span><span class="o">;</span> <span class="k">return</span><span class="o">}</span>
    <span class="k">case</span> <span class="sc">')'</span> <span class="k">=&gt;</span> <span class="o">{</span><span class="n">current</span> <span class="k">=</span> <span class="nc">CPAREN</span><span class="o">;</span> <span class="nv">ch</span><span class="o">.</span><span class="py">next</span><span class="o">;</span> <span class="k">return</span><span class="o">}</span>
    <span class="k">case</span> <span class="sc">'+'</span> <span class="k">=&gt;</span> <span class="o">{</span><span class="n">current</span> <span class="k">=</span> <span class="nc">PLUS</span><span class="o">;</span> <span class="nv">ch</span><span class="o">.</span><span class="py">next</span><span class="o">;</span> <span class="k">return</span><span class="o">}</span>
    <span class="k">case</span> <span class="sc">'/'</span> <span class="k">=&gt;</span> <span class="o">{</span><span class="n">current</span> <span class="k">=</span> <span class="nc">DIV</span><span class="o">;</span> <span class="nv">ch</span><span class="o">.</span><span class="py">next</span><span class="o">;</span> <span class="k">return</span><span class="o">}</span>
    <span class="k">case</span> <span class="sc">'*'</span> <span class="k">=&gt;</span> <span class="o">{</span><span class="n">current</span> <span class="k">=</span> <span class="nc">MUL</span><span class="o">;</span> <span class="nv">ch</span><span class="o">.</span><span class="py">next</span><span class="o">;</span> <span class="k">return</span><span class="o">}</span>
    <span class="k">case</span> <span class="sc">'='</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="c1">// more tricky because there can be =, �==</span>
    	<span class="nv">ch</span><span class="o">.</span><span class="py">next</span>
    	<span class="nf">if</span> <span class="o">(</span><span class="nv">ch</span><span class="o">.</span><span class="py">current</span> <span class="o">�==</span> <span class="sc">'='</span><span class="o">)</span> <span class="o">{</span><span class="nv">ch</span><span class="o">.</span><span class="py">next</span><span class="o">;</span> <span class="n">current</span> <span class="k">=</span> <span class="nc">CompareEQ</span><span class="o">;</span> <span class="k">return</span><span class="o">}</span>
    	<span class="k">else</span> <span class="o">{</span><span class="n">current</span> <span class="k">=</span> <span class="nc">AssignEQ</span><span class="o">;</span> <span class="k">return</span><span class="o">}</span>
    <span class="o">}</span>
    <span class="k">case</span> <span class="sc">'&lt;'</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="c1">// more tricky because there can be &lt;, &lt;=</span>
    <span class="nv">ch</span><span class="o">.</span><span class="py">next</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nv">ch</span><span class="o">.</span><span class="py">current</span> <span class="o">==</span> <span class="sc">'='</span><span class="o">)</span> <span class="o">{</span><span class="nv">ch</span><span class="o">.</span><span class="py">next</span><span class="o">;</span> <span class="n">current</span> <span class="k">=</span> <span class="nc">LEQ</span><span class="o">;</span> <span class="k">return</span><span class="o">}</span>
    	<span class="k">else</span> <span class="o">{</span><span class="n">current</span> <span class="k">=</span> <span class="nc">LESS</span><span class="o">;</span> <span class="k">return</span><span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="longest-match-rule">longest match rule</h5>

<p><img src="/assets/images/compiler\Snipaste_2021-12-09_23-56-49.png" alt="" /></p>

<h5 id="token-priority">token priority</h5>

<p>for a word is both identifier and keyword, which should we assign? Set a priority so match the keyword first</p>

<h4 id="general-approach-to-automatic-lexing">general approach to automatic lexing</h4>

<h5 id="traditional-approach">traditional approach</h5>

<ol>
  <li>convert to nondeterministic finite-state automaton</li>
  <li>perform determinization (can be expensive)</li>
  <li>run the resulting automaton on input (linear in the input size)</li>
</ol>

<h5 id="brzozowskis-derivatives">Brzozowskis derivatives</h5>

<p>accepts: (e, w) -&gt; {true, false}   e: regular expression, w: input word</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">accepts</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">epsilon</span><span class="o">)</span> <span class="k">=</span> <span class="nf">nullable</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>

<span class="nf">accepts</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">cu</span><span class="o">)</span> <span class="k">=</span> 
	<span class="k">if</span> <span class="n">e</span> <span class="k">=</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="n">e</span> <span class="k">=</span> <span class="n">epsilon</span><span class="o">,</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="n">e</span> <span class="k">=</span> <span class="n">c</span><span class="o">,</span> <span class="nf">if</span><span class="o">(</span><span class="n">u</span> <span class="k">=</span> <span class="n">epsilon</span><span class="o">)</span> <span class="kc">true</span> <span class="k">else</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="n">e</span> <span class="k">=</span> <span class="n">d</span><span class="o">,</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="n">e</span> <span class="k">=</span> <span class="n">e1</span> <span class="o">|</span> <span class="n">e2</span><span class="o">,</span> <span class="nf">accepts</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span> <span class="o">||</span> <span class="nf">accepts</span><span class="o">(</span><span class="n">e2</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span>
	<span class="k">if</span> <span class="n">e</span> <span class="k">=</span> <span class="n">e1e2</span><span class="o">,</span> <span class="o">???</span> <span class="c1">// need to try all splits of w?</span>
	<span class="k">if</span> <span class="n">e</span> <span class="k">=</span> <span class="n">e1</span><span class="o">*,</span> <span class="o">???</span>
</code></pre></div></div>

<p>after consume a given letter, what is the rest of the regex?</p>

<p>definition:</p>

<p>The derivative of a regex e with respect to letter c, written as $\delta^c(e)$, is defined as:</p>

<p>​				$L(\delta^c(e)) = \set{w \mid cw \in L(e)}$</p>

<p>the derivative of a regex is still a regex</p>

<p>some examples:</p>

<table>
  <tbody>
    <tr>
      <td>$\delta^a(ab</td>
      <td>ac</td>
      <td>da)=b</td>
      <td>c$</td>
    </tr>
  </tbody>
</table>

<p>$\delta^a((ab)^<em>)=b(ab)^</em>$</p>

<table>
  <tbody>
    <tr>
      <td>$\delta^a((ab</td>
      <td>c)^*ad)=b(ab</td>
      <td>c)^*ad \mid d$</td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/images/compiler\Snipaste_2021-12-10_14-46-11.png" style="zoom:80%;" /></p>

<h5 id="matching-regex-by-derivation">matching regex by derivation</h5>

<p>accepts: (e, w) -&gt; {true, false}   e: regular expression, w: input word</p>

<p>accepts(e, epsilon) = nullable(e)</p>

<p>accepts(e, cw) = accepts($\delta^c(e)$, w)</p>

<p>Important: need to cache each intermediate result to avoid duplicate calculation</p>

<h5 id="regular-expression-in-scala">regular expression in Scala</h5>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">enum</span> <span class="nc">RegExp</span><span class="k">:</span>
    <span class="c1">// empty language∅</span>
    <span class="k">case</span> <span class="nc">Failure</span>
    <span class="c1">// empty wordϵ</span>
    <span class="k">case</span> <span class="nc">EmptyStr</span>
    <span class="c1">// character a such that predicate(a)</span>
    <span class="k">case</span> <span class="nc">CharWhere</span><span class="o">(</span><span class="n">predicate</span><span class="k">:</span> <span class="kt">Character</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span>
    <span class="c1">// union left|right</span>
    <span class="k">case</span> <span class="nc">Union</span><span class="o">(</span><span class="n">left</span><span class="k">:</span> <span class="kt">RegExp</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">RegExp</span><span class="o">)</span>
    <span class="c1">// concatenation first|second</span>
    <span class="k">case</span> <span class="nc">Concat</span><span class="o">(</span><span class="n">first</span><span class="k">:</span> <span class="kt">RegExp</span><span class="o">,</span> <span class="n">second</span><span class="k">:</span> <span class="kt">RegExp</span><span class="o">)</span>
    <span class="c1">// Kleene star underlying∗</span>
    <span class="k">case</span> <span class="nc">Star</span><span class="o">(</span><span class="n">underlying</span><span class="k">:</span> <span class="kt">RegExp</span><span class="o">)</span>

    <span class="c1">// is this regexp nullable?</span>
    <span class="k">def</span> <span class="nf">acceptsEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>

    <span class="c1">// can this regexp possibly accept some words?</span>
    <span class="k">def</span> <span class="nf">isProductive</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="k">this</span> <span class="k">match</span>
        <span class="k">case</span> <span class="nc">Failure</span> <span class="k">=&gt;</span> <span class="kc">false</span>
        <span class="k">case</span> <span class="nc">EmptyStr</span> <span class="o">|</span> <span class="nc">CharWhere</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="o">|</span> <span class="nc">Star</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span> <span class="c1">// approx.</span>
        <span class="k">case</span> <span class="nc">Union</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">l</span><span class="o">.</span><span class="py">isProductive</span> <span class="o">||</span> <span class="nv">r</span><span class="o">.</span><span class="py">isProductive</span>
        <span class="k">case</span> <span class="nc">Concat</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">l</span><span class="o">.</span><span class="py">isProductive</span> <span class="o">&amp;&amp;</span> <span class="nv">r</span><span class="o">.</span><span class="py">isProductive</span>

<span class="nf">extension</span> <span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">RegExpr</span><span class="o">)</span><span class="k">:</span>
    <span class="kt">def</span> <span class="kt">~</span> <span class="o">(</span><span class="kt">that:</span> <span class="kt">RegExpr</span><span class="o">)</span><span class="kt">:</span> <span class="kt">RegExpr</span> <span class="o">=</span> <span class="nc">Concat</span><span class="o">(</span><span class="n">expr</span><span class="o">,</span> <span class="n">that</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">|</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">RegExpr</span><span class="o">)</span><span class="k">:</span> <span class="kt">RegExpr</span> <span class="o">=</span> <span class="nc">Union</span><span class="o">(</span><span class="n">expr</span><span class="o">,</span> <span class="n">that</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">*</span> <span class="k">:</span> <span class="kt">RegExpr</span> <span class="o">=</span> <span class="nc">Star</span><span class="o">(</span><span class="n">expr</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">?</span> <span class="k">:</span> <span class="kt">RegExpr</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">|</span> <span class="nc">EmptyStr</span>
    <span class="k">def</span> <span class="nf">+</span> <span class="k">:</span> <span class="kt">RegExpr</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">~</span> <span class="n">expr</span><span class="o">.*</span>
    <span class="k">def</span> <span class="nf">times</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">RegExpr</span> <span class="o">=</span>
    	<span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">EmptyStr</span> <span class="k">else</span> <span class="n">expr</span> <span class="o">~</span> <span class="nv">expr</span><span class="o">.</span><span class="py">times</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span>

<span class="c1">// example</span>
<span class="c1">// e1 ~ e2 ~ e3 | e4</span>
<span class="c1">// e1.* | e2.+</span>

<span class="k">def</span> <span class="nf">elem</span><span class="o">(</span><span class="n">pred</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">RegExpr</span> <span class="o">=</span> <span class="nc">CharWhere</span><span class="o">(</span><span class="n">pred</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">elem</span><span class="o">(</span><span class="n">char</span><span class="k">:</span> <span class="kt">Char</span><span class="o">)</span><span class="k">:</span> <span class="kt">RegExpr</span> <span class="o">=</span> <span class="nc">CharWhere</span><span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="n">char</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">elem</span><span class="o">(</span><span class="n">chars</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Char</span><span class="o">])</span><span class="k">:</span> <span class="kt">RegExpr</span> <span class="o">=</span>
	<span class="nv">chars</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">elem</span><span class="o">).</span><span class="py">foldLeft</span><span class="o">[</span><span class="kt">RegExpr</span><span class="o">](</span><span class="nc">Failure</span><span class="o">)(</span><span class="k">_</span> <span class="o">|</span> <span class="k">_</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">word</span><span class="o">(</span><span class="n">chars</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Char</span><span class="o">])</span><span class="k">:</span> <span class="kt">RegExpr</span> <span class="o">=</span>
	<span class="nv">chars</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">elem</span><span class="o">).</span><span class="py">foldLeft</span><span class="o">[</span><span class="kt">RegExpr</span><span class="o">](</span><span class="nc">EmptyStr</span><span class="o">)(</span><span class="k">_</span> <span class="o">~</span> <span class="k">_</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">inRange</span><span class="o">(</span><span class="n">low</span><span class="k">:</span> <span class="kt">Char</span><span class="o">,</span> <span class="n">high</span><span class="k">:</span> <span class="kt">Char</span><span class="o">)</span><span class="k">:</span> <span class="kt">RegExpr</span> <span class="o">=</span>
	<span class="nf">elem</span><span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="n">low</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">)</span>

<span class="c1">// Example:</span>
<span class="nf">elem</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">isLetter</span><span class="o">)</span> <span class="o">~</span> <span class="o">(</span><span class="nf">elem</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">isLetter</span><span class="o">)</span> <span class="o">|</span> <span class="nf">elem</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">isDigit</span><span class="o">)).*</span>


<span class="k">def</span> <span class="nf">derive</span><span class="o">(</span><span class="n">char</span><span class="k">:</span> <span class="kt">Character</span><span class="o">)</span><span class="k">:</span> <span class="kt">RegExp</span> <span class="o">=</span>
    <span class="k">def</span> <span class="nf">work</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">RegExp</span><span class="o">)</span><span class="k">:</span> <span class="kt">RegExp</span> <span class="o">=</span> <span class="n">expr</span> <span class="k">match</span>
    	<span class="k">case</span> <span class="nc">Failure</span> <span class="o">|</span> <span class="nc">EmptyStr</span> <span class="k">=&gt;</span> <span class="nc">Failure</span>
    	<span class="k">case</span> <span class="nc">CharWhere</span><span class="o">(</span><span class="n">pred</span><span class="o">)</span> <span class="k">=&gt;</span>
    		<span class="nf">if</span><span class="o">(</span><span class="nf">pred</span><span class="o">(</span><span class="n">char</span><span class="o">))</span> <span class="nc">EmptyStr</span> <span class="k">else</span> <span class="nc">Failure</span>
    	<span class="k">case</span> <span class="nc">Union</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">work</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">|</span> <span class="nf">work</span><span class="o">(</span><span class="n">right</span><span class="o">)</span>
    	<span class="k">case</span> <span class="nc">Concat</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
    		<span class="k">val</span> <span class="nv">w</span> <span class="k">=</span> <span class="nf">work</span><span class="o">(</span><span class="n">left</span><span class="o">)</span> <span class="o">~</span> <span class="n">right</span>
    		<span class="nf">if</span><span class="o">(</span><span class="nv">left</span><span class="o">.</span><span class="py">acceptsEmpty</span><span class="o">)</span> <span class="n">w</span> <span class="o">|</span> <span class="nf">work</span><span class="o">(</span><span class="n">right</span><span class="o">)</span> <span class="k">else</span> <span class="n">w</span>
    	<span class="k">case</span> <span class="nc">Star</span><span class="o">(</span><span class="n">inner</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">work</span><span class="o">(</span><span class="n">inner</span><span class="o">)</span> <span class="o">~</span> <span class="n">expr</span>
    <span class="nf">work</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
</code></pre></div></div>

<h5 id="naïve-derivation-is-inefficient">naïve derivation is inefficient</h5>

<p><img src="/assets/images/compiler\Snipaste_2021-12-10_15-03-03.png" alt="" /></p>

<h5 id="solution-on-the-fly-normalization">solution: on-the-fly normalization</h5>

<ul>
  <li>associate all concatenation to the right: (e1e2)e3 =&gt; e1(e2e3)</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>avoid repetitions in unions: (e1</td>
          <td>e2)</td>
          <td>(e2</td>
          <td>e3) =&gt; e1</td>
          <td>e2</td>
          <td>e3</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<p>after removal,</p>

<p><img src="/assets/images/compiler\Snipaste_2021-12-10_15-13-03.png" style="zoom:50%; float: left" /></p>

<p>code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">deriveNorm</span><span class="o">(</span><span class="n">char</span><span class="k">:</span> <span class="kt">Character</span><span class="o">)</span><span class="k">:</span> <span class="kt">RegExp</span> <span class="o">=</span>
	<span class="k">val</span> <span class="nv">disjuncted</span> <span class="k">=</span> <span class="nv">collection</span><span class="o">.</span><span class="py">mutable</span><span class="o">.</span><span class="py">SortedSet</span><span class="o">[</span><span class="kt">RegExp</span><span class="o">]()</span>
	<span class="k">def</span> <span class="nf">work</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">RegExp</span><span class="o">,</span> <span class="n">rest</span><span class="k">:</span> <span class="kt">RegExp</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">expr</span> <span class="k">match</span>
		<span class="k">case</span> <span class="nc">CharWhere</span><span class="o">(</span><span class="n">pred</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">if</span><span class="o">(</span><span class="nf">pred</span><span class="o">(</span><span class="n">char</span><span class="o">))</span> <span class="n">disjuncted</span> <span class="o">+=</span> <span class="n">rest</span>
		<span class="k">case</span> <span class="nc">Union</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">work</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">rest</span><span class="o">);</span> <span class="nf">work</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span>
		<span class="k">case</span> <span class="nc">Concat</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
			<span class="nf">work</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">~</span> <span class="n">rest</span><span class="o">)</span>
			<span class="nf">if</span><span class="o">(</span><span class="nv">left</span><span class="o">.</span><span class="py">acceptsEmpty</span><span class="o">)</span> <span class="nf">work</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span>
		<span class="k">case</span> <span class="nc">Star</span><span class="o">(</span><span class="n">inner</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">work</span><span class="o">(</span><span class="n">inner</span><span class="o">,</span> <span class="n">expr</span> <span class="o">~</span> <span class="n">rest</span><span class="o">)</span>
		<span class="k">case</span> <span class="nc">Failure</span> <span class="o">|</span> <span class="nc">EmptyStr</span> <span class="k">=&gt;</span> <span class="o">()</span>
	<span class="nf">work</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="nc">EmptyStr</span><span class="o">)</span> <span class="c1">// register unions into `disjuncted`</span>
	<span class="nv">disjuncted</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">[</span><span class="kt">RegExp</span><span class="o">](</span><span class="nc">Failure</span><span class="o">)(</span><span class="k">_</span> <span class="o">|</span> <span class="k">_</span><span class="o">)</span> <span class="c1">// rebuild regexp</span>
</code></pre></div></div>

<h5 id="the-pumping-lemma">the pumping lemma</h5>

<p>regular expression: though infinite, they contain a simple repeating pattern</p>

<p><img src="/assets/images/compiler\Snipaste_2021-12-10_15-10-05.png" style="zoom:80%;" /></p>

<h4 id="theory-of-normalizing-derivation">theory of normalizing derivation</h4>

<p>this part is where I cannot understand.</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_15-22-58.png" alt="" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_15-25-23.png" alt="" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_15-26-17.png" alt="" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_15-27-48.png" alt="" /></p>

<p>Thus, number of distinct regexs generated by normalizing derivation of any w <strong>is bounded</strong>!</p>

<p>more specifically, for any e, we have:</p>

<table>
  <tbody>
    <tr>
      <td>​		$</td>
      <td>\set{\underline\delta^w(e) \mid w \in A^*}</td>
      <td>\le 1+2^{</td>
      <td>max(e, \epsilon)</td>
      <td>}$</td>
    </tr>
  </tbody>
</table>

<p>this allows regex matching in constant space and linear time w.r.t. size of words</p>

<h4 id="algorithm-for-regex-matching">algorithm for regex matching</h4>

<ul>
  <li>start with empty mapping M := $\empty$ and with regex e</li>
  <li>For each i^th^ character in c~i~ in w
    <ul>
      <li>if (e, c~i~) not in domain(M), set M(e, c~i~) := $\underline\delta^{c_i}(e)$</li>
      <li>set e := M(e, c~i~)</li>
    </ul>
  </li>
  <li>Test whether nullable(e)</li>
</ul>

<h4 id="expressiveness-limitation-of-regex">expressiveness limitation of regex</h4>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_15-44-58.png" style="zoom:60%;float:left" /></p>

<h2 id="grammars">grammars</h2>

<h3 id="regular-grammar">regular grammar</h3>

<p>an equivalent way of defining regular languages</p>

<table>
  <tbody>
    <tr>
      <td>​	start -&gt; letter(letter</td>
      <td>digit)*</td>
    </tr>
  </tbody>
</table>

<p>​	letter -&gt; [a..z]</p>

<table>
  <tbody>
    <tr>
      <td>​	digit -&gt; 0</td>
      <td>1</td>
      <td>…</td>
      <td>9</td>
    </tr>
  </tbody>
</table>

<p><strong>regularity requirement</strong>: no recursion!</p>

<p>definitions form a directed acyclic graph (DAG)</p>

<h3 id="context-free-grammar">context free grammar</h3>

<p>$S \rightarrow \epsilon \mid a~S~b$</p>

<p>semantics given by rewriting derivations</p>

<p>S -&gt; aSb -&gt; aaSbb -&gt; aaaSbbb -&gt; aaa(epsilon)bbb = aaabbb</p>

<h4 id="definition-of-a-context-free-grammars-cfg">definition of a Context-Free Grammars (CFG)</h4>

<p>a tuple G = (A, N, S, R)</p>

<ul>
  <li>A - terminals (usually tokens, endpoint)</li>
  <li>N - non-terminals (symbols with recursive definitions)</li>
  <li>R - grammar rules as pair n -&gt; v, where n is a non-terminal, $v \in (A \cup N)^*$</li>
  <li>S - starting symbol S</li>
  <li>G - the derivation starts from S</li>
</ul>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_15-57-49.png" style="zoom:60%;" /></p>

<h3 id="parse-trees">parse trees</h3>

<h4 id="definition-1">definition</h4>

<p>a tree t is a parse tree of G = (A, N, S, R) iff t is a node-labelled tree with ordered children that satisfies:</p>

<ul>
  <li>
    <p>root is labeled by S</p>
  </li>
  <li>
    <p>leaves are labelled by elements of A</p>
  </li>
  <li>
    <p>each non-leaf node is labelled by an element of N</p>
  </li>
  <li>
    <p>for each non-leaf node labelled by n,</p>

    <p>​	whose children left to right are p~1~, … p~k~</p>

    <p>​	there is a rule (n -&gt; p~1~ … p~k~) belongs to R</p>
  </li>
  <li>
    <p>the <em>yield</em> of parse tree t: a word obtained by the leaves of t</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>the <em>language</em> of grammar G: defined as L(G) = {<em>yield</em>(t)</td>
          <td>t is a parse tree of G}</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="example">example</h4>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_16-06-12.png" style="zoom:60%;float:left" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_16-06-27.png" style="zoom:60%;float:left" /></p>

<h3 id="syntax-tree">syntax tree</h3>

<p>Difference between parse trees and abstract syntax trees</p>

<p>Node children in parse trees correspond precisely to RHS of grammar rules</p>

<ul>
  <li>Definition of parse trees is fixed given the grammar. Often, compilers never actually build parse trees in memory</li>
  <li>uniquely specify how an input was recognized by the grammar</li>
  <li>contains all information needed to reconstruct the input</li>
</ul>

<p>Nodes in abstract syntax tree (AST) contain only useful information</p>

<ul>
  <li>We can choose our own syntax trees, to facilitate both construction and processing in later stages of compiler</li>
</ul>

<p>Compilers often directly builds ASTs</p>

<h3 id="ambiguous-grammar">ambiguous grammar</h3>

<p>how to parse “x * 42 + y” ?</p>

<p>some token sequences have multiple parse trees =&gt; ambiguous</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_16-12-07.png" style="zoom:60%;" /></p>

<p>solution: change the grammar to layered form</p>

<table>
  <tbody>
    <tr>
      <td>​		expr -&gt; expr + expr</td>
      <td>multi</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>​		multi -&gt; intLiteral</td>
      <td>ident</td>
      <td>multi * multi</td>
      <td>’(‘ expr ‘)’</td>
    </tr>
  </tbody>
</table>

<p>but how to parse “x + 42 + y” ?</p>

<p>we need to define the associative rule. For ‘+’, we want it to be left-associative, x+42+y = (x+42)+y</p>

<p>solution:</p>

<table>
  <tbody>
    <tr>
      <td>​		expr -&gt; expr + multi</td>
      <td>multi</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>​		multi -&gt; multi * factor</td>
      <td>factor</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>​		factor -&gt; intLiteral</td>
      <td>indent</td>
      <td>’(‘ expr ‘)’</td>
    </tr>
  </tbody>
</table>

<p>such a grammar is <strong>left recursive</strong>, since expr -&gt; expr + …</p>

<h3 id="generalities-on-grammar">generalities on grammar</h3>

<p>Chomskys Classification of Grammars</p>

<ul>
  <li>type 0, unrestricted: arbitrary string rewrite rules
    <ul>
      <li>equivalent to Turing machines!</li>
      <li>eXb -&gt; eXeX -&gt; Y</li>
    </ul>
  </li>
  <li>type 1, context sensitive: RHS always larger
    <ul>
      <li>O(n)-space Turing machines</li>
      <li>aXb -&gt; acXb</li>
    </ul>
  </li>
  <li>type 2, context free: one LHS nonterminal
    <ul>
      <li>X -&gt; acXb</li>
    </ul>
  </li>
  <li>type 3, regular: no recursion, just Kleene star
    <ul>
      <li>X -&gt; acY*b</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_16-41-23.png" style="zoom:60%;" /></p>

<h2 id="parsing">parsing</h2>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_16-22-47.png" style="zoom:60%;" /></p>

<h3 id="recursive-descent-ll1-parsing">recursive descent LL(1) parsing</h3>

<ul>
  <li>Can be easily implemented manually based on the grammar</li>
  <li>Efficient – linear in the size of the token sequence</li>
  <li>Direct correspondence between grammar and code</li>
</ul>

<p>a simple example:</p>

<pre><code class="language-pseudocode">statmt ::= 
    println ( stringConst , ident )
    | ident = expr
    | if ( expr ) statmt (else statmt)?
    | while ( expr ) statmt
    | { statmt* }
</code></pre>

<p>a simple parser could be:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">skip</span><span class="o">(</span><span class="n">t</span> <span class="k">:</span> <span class="kt">Token</span><span class="o">)</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">lexer</span><span class="o">.</span><span class="py">token</span> <span class="o">==</span> <span class="n">t</span><span class="o">)</span> <span class="nv">lexer</span><span class="o">.</span><span class="py">next</span> 
   <span class="k">else</span> <span class="nf">error</span><span class="o">(</span><span class="err">“</span><span class="nc">Expected</span><span class="err">”</span><span class="o">+</span> <span class="n">t</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">statmt</span> <span class="k">=</span> <span class="o">{</span>
   <span class="nf">if</span> <span class="o">(</span><span class="nv">lexer</span><span class="o">.</span><span class="py">token</span> <span class="o">==</span> <span class="nc">Println</span><span class="o">)</span> <span class="o">{</span> <span class="nv">lexer</span><span class="o">.</span><span class="py">next</span><span class="o">;</span>
      <span class="nf">skip</span><span class="o">(</span><span class="n">openParen</span><span class="o">);</span> <span class="nf">skip</span><span class="o">(</span><span class="n">stringConst</span><span class="o">);</span> <span class="nf">skip</span><span class="o">(</span><span class="n">comma</span><span class="o">);</span>
      <span class="nf">skip</span><span class="o">(</span><span class="n">identifier</span><span class="o">);</span> <span class="nf">skip</span><span class="o">(</span><span class="n">closedParen</span><span class="o">)</span>
   <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">lexer</span><span class="o">.</span><span class="py">token</span> <span class="o">==</span> <span class="nc">Ident</span><span class="o">)</span> <span class="o">{</span> <span class="nv">lexer</span><span class="o">.</span><span class="py">next</span><span class="o">;</span>
      <span class="nf">skip</span><span class="o">(</span><span class="n">equality</span><span class="o">);</span> <span class="n">expr</span>
   <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">lexer</span><span class="o">.</span><span class="py">token</span> <span class="o">==</span> <span class="n">ifKeyword</span><span class="o">)</span> <span class="o">{</span> <span class="nv">lexer</span><span class="o">.</span><span class="py">next</span><span class="o">;</span>
      <span class="nf">skip</span><span class="o">(</span><span class="n">openParen</span><span class="o">);</span> <span class="n">expr</span><span class="o">;</span> <span class="nf">skip</span><span class="o">(</span><span class="n">closedParen</span><span class="o">);</span> <span class="n">statmt</span><span class="o">;</span>
      <span class="nf">if</span> <span class="o">(</span><span class="nv">lexer</span><span class="o">.</span><span class="py">token</span> <span class="o">==</span> <span class="n">elseKeyword</span><span class="o">)</span> <span class="o">{</span> <span class="nv">lexer</span><span class="o">.</span><span class="py">next</span><span class="o">;</span> <span class="n">statmt</span> <span class="o">}</span>
   <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">lexer</span><span class="o">.</span><span class="py">token</span> <span class="o">==</span> <span class="n">whileKeyword</span><span class="o">)</span> <span class="o">{</span> <span class="nv">lexer</span><span class="o">.</span><span class="py">next</span><span class="o">;</span>
      <span class="nf">skip</span><span class="o">(</span><span class="n">openParen</span><span class="o">);</span> <span class="n">expr</span><span class="o">;</span> <span class="nf">skip</span><span class="o">(</span><span class="n">closedParen</span><span class="o">);</span> <span class="n">statmt</span>
   <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">lexer</span><span class="o">.</span><span class="py">token</span> <span class="o">==</span> <span class="n">openBrace</span><span class="o">)</span> <span class="o">{</span> <span class="nv">lexer</span><span class="o">.</span><span class="py">next</span><span class="o">;</span>
      <span class="nf">while</span> <span class="o">(</span><span class="n">isFirstOfStatmt</span><span class="o">)</span> <span class="o">{</span> <span class="n">statmt</span> <span class="o">}</span>
      <span class="nf">skip</span><span class="o">(</span><span class="n">closedBrace</span><span class="o">)</span>
 <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="nf">error</span><span class="o">(</span><span class="err">“</span><span class="nc">Unknown</span> <span class="n">statement</span><span class="o">,</span> <span class="n">found</span> <span class="n">token</span> <span class="err">”</span> <span class="o">+</span> <span class="nv">lexer</span><span class="o">.</span><span class="py">token</span><span class="o">)</span>  <span class="o">}</span>
</code></pre></div></div>

<p>because we have terminals at the beginning of each alternative, which rule to parse is quite easy to get.</p>

<p>now look at another example:</p>

<pre><code class="language-pseudocode">%% the priority is similar to java
expr ::= expr ( +|-|*|/ ) expr
		| name
		| '(' expr ')'
name ::= ident
</code></pre>

<p>we can transform it to the abstract syntax tree:</p>

<pre><code class="language-pseudocode">expr ::= term termList
termList ::= + term termList
			| - term termList
			| epsilon
term ::= factor factorList
factorList ::= * factor factorList
			| / factor factorList
            | epsilon
factor ::= name | ( expr )
name ::= ident
</code></pre>

<p>corresponding code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">expr</span> <span class="k">=</span> <span class="o">{</span> <span class="n">term</span><span class="o">;</span> <span class="n">termList</span> <span class="o">}</span>
<span class="k">def</span> <span class="nf">termList</span> <span class="k">=</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">token</span><span class="o">==</span><span class="nc">PLUS</span><span class="o">)</span> <span class="o">{</span>
     <span class="nf">skip</span><span class="o">(</span><span class="nc">PLUS</span><span class="o">);</span> <span class="n">term</span><span class="o">;</span> <span class="n">termList</span>
  <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">token</span><span class="o">==</span><span class="nc">MINUS</span><span class="o">)</span>
     <span class="nf">skip</span><span class="o">(</span><span class="nc">MINUS</span><span class="o">);</span> <span class="n">term</span><span class="o">;</span> <span class="n">termList</span>
  <span class="o">}</span>
<span class="k">def</span> <span class="nf">term</span> <span class="k">=</span> <span class="o">{</span> <span class="n">factor</span><span class="o">;</span> <span class="n">factorList</span> <span class="o">}</span>
<span class="o">...</span>
<span class="k">def</span> <span class="nf">factor</span> <span class="k">=</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">token</span><span class="o">==</span><span class="nc">IDENT</span><span class="o">)</span> <span class="n">name</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">token</span><span class="o">==</span><span class="nc">OPAR</span><span class="o">)</span> <span class="o">{</span>
    <span class="nf">skip</span><span class="o">(</span><span class="nc">OPAR</span><span class="o">);</span> <span class="n">expr</span><span class="o">;</span> <span class="nf">skip</span><span class="o">(</span><span class="nc">CPAR</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">else</span> <span class="nf">error</span><span class="o">(</span><span class="s">"expected ident or )"</span><span class="o">)</span>
</code></pre></div></div>

<p>we need to rewrite the AST so that:</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_19-07-32.png" style="zoom:60%;" /></p>

<h4 id="algorithm-for-first-and-null">algorithm for <em>first</em> and <em>null</em></h4>

<p>$first(A) = first(B_1…B_p) \cup first(C_1…C_p) \cup first(D_1…D_p)$</p>

<p>$first(B_1…B_p) = \left{ 
  \begin{array}{ c l }
    first(B_1) &amp;  \text{if not } nullable(B_1) <br />
    first(B_1) \cup …\cup first(B_k) &amp;  \text{if } nullable(B_1),…, nullable(B_{k-1}) \text{ and not } nullable(B_k)
  \end{array}
\right.$</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_19-18-31.png" style="zoom:67%;" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_19-21-15.png" style="zoom: 67%;" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_19-23-18.png" style="zoom:67%;" /></p>

<p>thus, given any grammar, we can:</p>

<ul>
  <li>for each non-terminal X, whether nullable(X)</li>
  <li>using this, get the set of first(X) for each non-terminal</li>
</ul>

<p>pseudo code for getting the constraints:</p>

<pre><code class="language-pseudocode">nullable = {}
changed = true
while (changed) {
  changed = false
  for each non-terminal X
    if (X is not nullable) and (grammar contains rule X ::= ε | ...     ) 
    	or (grammar contains rule     X ::= Y1 ... Yn | ... where {Y1,...,Yn} in nullable)
    then {
        nullable = nullable U {X}
        changed = true
    }
}

for each nonterminal X: first(X) = {}
for each terminal t:  first(t) = {t}
loop
  for each grammar rule X ::= Y(1) ... Y(k)
  for i = 1 to k
      if i=1 or {Y(1),...,Y(i-1)}  in nullable 
      then
        first(X) = first(X) U first(Y(i))
until none of first(…) changed in last itera#on
</code></pre>

<h4 id="problem-with-nullable-non-terminal">problem with nullable non-terminal</h4>

<p>there are still some cases cannot be determined only using first set:</p>

<pre><code class="language-pseudocode">stmtList ::= ε | stmt  stmtList 
stmt ::= assign | block 
assign ::= ID  =  ID
block ::= beginof ID stmtList ID ends

def stmtList = 
  if (???) 			// what should the condition be?
  else { stmt; stmtList }
def stmt =
  if (lex.token == ID) assign
  else if (lex.token == beginof) block
  else error(“Syntax error: expected ID or beginonf”)
…
def block =
  { skip(beginof); skip(ID); stmtList; skip(ID); skip(ends) }
</code></pre>

<p>we cannot determine if stmtList is null or continue parsing:</p>

<p>For nullable non-terminals, we must also compute what <strong><em>follows</em></strong> them</p>

<p>parsing the block, beginof ID stmtList ID ends, after we consume beginof, ID, next we see is also an ID, what is this ID for? a new assignment? or the ID end? In LL(1) grammar, by just looking at next token, this is not determined!</p>

<h4 id="ll1-grammar">LL(1) grammar</h4>

<ul>
  <li>Grammar is LL(1) if for each nonterminal X
    <ul>
      <li>first sets of different alternatives of X are dijoint</li>
      <li>if nullable(X), first(X) must be disjoint from follow(X) and only one alternative of X maybe nullable</li>
    </ul>
  </li>
  <li>For each LL(1) grammar we can build recursive-descent parser</li>
  <li>Each LL(1) grammar is unambiguous</li>
  <li>If a grammar is not LL(1), we can sometimes transform it into equivalent LL(1) grammar</li>
</ul>

<p>So for the above stmtList example, it is not LL(1) because:</p>

<ul>
  <li>nullable(stmtList)</li>
  <li>first(stmtList) = {ID, beginof}</li>
  <li>follow(stmtList) = {ID}</li>
  <li>$first(stmt) \cap follow(stmtList) = {ID}$</li>
</ul>

<h4 id="algorithm-for-follow">algorithm for <em>follow</em></h4>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_19-56-37.png" style="zoom:67%;" /></p>

<h4 id="ll1-parse-table">LL(1) parse table</h4>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_20-00-50.png" style="zoom:67%;" /></p>

<h3 id="concrete-parser-implementation">concrete parser implementation</h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">enum</span> <span class="nc">Token</span><span class="k">:</span>
    <span class="kt">case</span> <span class="kt">Ident</span><span class="o">(</span><span class="kt">name:</span> <span class="kt">String</span><span class="o">)</span>
    <span class="kt">case</span> <span class="kt">OpenParen</span>
    <span class="k">case</span> <span class="nc">CloseParen</span>
    <span class="k">case</span> <span class="nc">Plus</span>
    <span class="k">case</span> <span class="nc">Times</span>
<span class="c1">// "A + B * C" =&gt; Ident("A"),Plus,Ident("B"),Times,Ident("C")</span>

<span class="n">enum</span> <span class="nc">Expr</span><span class="k">:</span>
    <span class="kt">case</span> <span class="kt">Var</span><span class="o">(</span><span class="kt">name:</span> <span class="kt">String</span><span class="o">)</span>
    <span class="kt">case</span> <span class="kt">Add</span><span class="o">(</span><span class="kt">lhs:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="kt">rhs:</span> <span class="kt">Expr</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Mult</span><span class="o">(</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">rhs</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span>
<span class="c1">// "A + B * C" =&gt; Add( Var("A") , Mult(Var("B"), Var("C")) )</span>

<span class="k">class</span> <span class="nc">Parser</span><span class="o">(</span><span class="n">ite</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Token</span><span class="o">])</span><span class="k">:</span>
	<span class="c1">// Parser state manipulation:</span>
	<span class="k">var</span> <span class="n">cur</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Token</span><span class="o">]</span> <span class="k">=</span> <span class="nv">ite</span><span class="o">.</span><span class="py">nextOption</span>
	<span class="k">def</span> <span class="nf">consume</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
		<span class="n">cur</span> <span class="k">=</span> <span class="nv">ite</span><span class="o">.</span><span class="py">nextOption</span>
	<span class="c1">// define parser here:</span>
	<span class="k">def</span> <span class="nf">expr</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">object</span> <span class="nc">Parser</span><span class="k">:</span>
	<span class="kt">def</span> <span class="kt">parse</span><span class="o">(</span><span class="kt">ts:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Token</span><span class="o">])</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span>
		<span class="k">val</span> <span class="nv">p</span> <span class="k">=</span> <span class="nc">Parser</span><span class="o">(</span><span class="nv">ts</span><span class="o">.</span><span class="py">iterator</span><span class="o">)</span>
		<span class="k">val</span> <span class="nv">res</span> <span class="k">=</span> <span class="nv">p</span><span class="o">.</span><span class="py">expr</span> <span class="c1">// entry point</span>
		<span class="nf">if</span> <span class="o">(</span><span class="nv">p</span><span class="o">.</span><span class="py">cur</span><span class="o">.</span><span class="py">nonEmpty</span><span class="o">)</span>
			<span class="nf">fail</span><span class="o">(</span><span class="s">"input not fully consumed"</span><span class="o">)</span>
		<span class="n">res</span>

<span class="c1">// Helper method:</span>
<span class="k">def</span> <span class="nf">skip</span><span class="o">(</span><span class="n">tk</span><span class="k">:</span> <span class="kt">Token</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">tk</span><span class="o">))</span>
		<span class="nf">fail</span><span class="o">(</span><span class="s">"expected "</span> <span class="o">+</span> <span class="n">tk</span> <span class="o">+</span> <span class="s">", found "</span> <span class="o">+</span> <span class="n">cur</span><span class="o">)</span>
	<span class="n">consume</span>

<span class="c1">// Unambiguous "atomic" expressions:</span>
<span class="k">def</span> <span class="nf">atom</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> 
	<span class="n">cur</span> <span class="k">match</span>
		<span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Ident</span><span class="o">(</span><span class="n">nme</span><span class="o">))</span> <span class="k">=&gt;</span> 
			<span class="n">consume</span>
			<span class="nc">Var</span><span class="o">(</span><span class="n">nme</span><span class="o">)</span>
		<span class="k">case</span> <span class="nc">OpenParen</span> <span class="k">=&gt;</span>
			<span class="n">consume</span>
			<span class="k">val</span> <span class="nv">e</span> <span class="k">=</span> <span class="n">expr</span>
			<span class="nf">skip</span><span class="o">(</span><span class="nc">CloseParen</span><span class="o">)</span>
			<span class="n">e</span>
		<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nf">fail</span><span class="o">(</span><span class="s">"expected atomic expression, found "</span> <span class="o">+</span> <span class="n">cur</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">expr</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span>
	<span class="k">val</span> <span class="nv">p</span> <span class="k">=</span> <span class="n">product</span>
	<span class="k">val</span> <span class="nv">ps</span> <span class="k">=</span> <span class="n">addedProducts</span>
	<span class="nv">ps</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="n">p</span><span class="o">)((</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Add</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">))</span>

<span class="k">def</span> <span class="nf">addedProducts</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Expr</span><span class="o">]</span> <span class="k">=</span> <span class="o">\</span>
	<span class="n">cur</span> <span class="k">match</span>
		<span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Plus</span><span class="o">)</span> <span class="k">=&gt;</span>
			<span class="n">consume</span>
			<span class="n">product</span> <span class="o">::</span> <span class="n">addedProducts</span>
		<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Nil</span>

<span class="k">def</span> <span class="nf">product</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span>
	<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="n">atom</span>
	<span class="k">val</span> <span class="nv">as</span> <span class="k">=</span> <span class="n">multipliedAtoms</span>
	<span class="nv">as</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="n">a</span><span class="o">)((</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Mult</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">))</span>

<span class="k">def</span> <span class="nf">multipliedAtoms</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Expr</span><span class="o">]</span> <span class="k">=</span> <span class="n">cur</span> <span class="k">match</span>
	<span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Times</span><span class="o">)</span> <span class="k">=&gt;</span>
		<span class="n">consume</span>
		<span class="n">product</span> <span class="o">::</span> <span class="n">addedProducts</span>
	<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Nil</span>
</code></pre></div></div>

<h3 id="pratt-parsing">Pratt Parsing</h3>

<p>how to avoid manually transforming grammars?</p>

<p>how to support user-defined operators and parse them correctly?</p>

<p>===&gt; We need separately specify operator precedence / associativity</p>

<h4 id="idea">idea</h4>

<p>Simplest way of describing precedence and associativity:</p>

<p>​	operators have distinct left and right precedences</p>

<p>​	‘+’ has (3,4) and ‘*’ has (5,6)</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_20-23-59.png" style="zoom:50%;" /></p>

<h4 id="implementation">implementation</h4>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">opPrec</span><span class="o">(</span><span class="n">opStr</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">opStr</span> <span class="k">match</span>
    <span class="k">case</span> <span class="s">"*"</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mi">50</span><span class="o">,</span> <span class="mi">51</span><span class="o">)</span>
    <span class="k">case</span> <span class="s">"+"</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mi">30</span><span class="o">,</span> <span class="mi">31</span><span class="o">)</span>
    <span class="k">case</span> <span class="s">"=&gt;"</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mi">21</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span>
    <span class="k">case</span> <span class="o">...</span>

<span class="n">enum</span> <span class="nc">Token</span><span class="k">:</span>
	<span class="kt">case</span> <span class="kt">OpenParen</span>
	<span class="k">case</span> <span class="nc">CloseParen</span>
	<span class="k">case</span> <span class="nc">Ident</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
	<span class="k">case</span> <span class="nc">Oper</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="n">enum</span> <span class="nc">Expr</span><span class="k">:</span>
	<span class="kt">case</span> <span class="kt">Var</span><span class="o">(</span><span class="kt">name:</span> <span class="kt">String</span><span class="o">)</span>
	<span class="kt">case</span> <span class="kt">Infix</span><span class="o">(</span><span class="kt">lhs:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="kt">op:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">rhs</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">expr</span><span class="o">(</span><span class="n">prec</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> 
	<span class="n">cur</span> <span class="k">match</span>
		<span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Ident</span><span class="o">(</span><span class="n">nme</span><span class="o">))</span> <span class="k">=&gt;</span>
			<span class="n">consume</span><span class="o">;</span> <span class="nf">exprCont</span><span class="o">(</span><span class="nc">Var</span><span class="o">(</span><span class="n">nme</span><span class="o">),</span> <span class="n">prec</span><span class="o">)</span>
		<span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">OpenParen</span><span class="o">)</span> <span class="k">=&gt;</span>
			<span class="n">consume</span><span class="o">;</span> <span class="k">val</span> <span class="nv">res</span> <span class="k">=</span> <span class="nf">expr</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="nf">skip</span><span class="o">(</span><span class="nc">CloseParen</span><span class="o">)</span>
			<span class="nf">exprCont</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">prec</span><span class="o">)</span>
		<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nf">fail</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span>

<span class="c1">// Having parsed acc, what to do next at this precedence?</span>
<span class="k">def</span> <span class="nf">exprCont</span><span class="o">(</span><span class="n">acc</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">prec</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">cur</span> <span class="k">match</span>
	<span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Oper</span><span class="o">(</span><span class="n">opStr</span><span class="o">))</span> <span class="k">if</span> <span class="nf">opPrec</span><span class="o">(</span><span class="n">opStr</span><span class="o">).</span><span class="py">_1</span> <span class="o">&gt;</span> <span class="n">prec</span> <span class="k">=&gt;</span>
		<span class="n">consume</span>
		<span class="k">val</span> <span class="nv">rhs</span> <span class="k">=</span> <span class="nf">expr</span><span class="o">(</span><span class="nf">opPrec</span><span class="o">(</span><span class="n">opStr</span><span class="o">).</span><span class="py">_2</span><span class="o">)</span>
		<span class="nf">exprCont</span><span class="o">(</span><span class="nc">Infix</span><span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">opStr</span><span class="o">,</span> <span class="n">rhs</span><span class="o">),</span> <span class="n">prec</span><span class="o">)</span>
	<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">acc</span>
</code></pre></div></div>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_20-36-33.png" style="zoom:50%;" /></p>

<h4 id="user-defined-operators">user defined operators</h4>

<h4 id="character-precedence-tables">character precedence tables</h4>

<h3 id="parsing-expression-grammars-peg">parsing-expression grammars (PEG)</h3>

<p>more recent alternative to context-free grammars (CFG)
Parsing-Expression Grammars remove ambiguities through biased choice:
	Instead of X|Y, use X/Y
which tries to parse Y only if parsing X fails!</p>

<h2 id="name-analysis">name analysis</h2>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_20-47-07.png" style="zoom:67%;" /></p>

<ul>
  <li>An identifier is used but not declared:
def p(amount: Int) { total = total + ammount }</li>
  <li>Multiple method arguments have the same name
def p(x:Int, y:Int, x:Int) { FF. }</li>
  <li>Multiple functions with the same name
object Program {
	def m(x: Int) = { x + 1 }
	def m(x: Int) = { x + 3 } }</li>
  <li>ill-formed type definition (e.g. circular)
class List extends Expr
class Cons extends List
class Expr extends Cons</li>
</ul>

<h3 id="symbol-table">symbol table</h3>

<p>maintain a map from identifiers to declaration information (symbol) at each point in the tree: <strong>symbol table</strong></p>

<p>symbol tables can be computed every time, cached, or integrated partly or fully into trees as symbol reference</p>

<p>it provides efficient access to information of identifiers</p>

<ul>
  <li>declaration of a value or variable, its type and initial value</li>
  <li>variable inside a pattern matching</li>
  <li>a function and its signatures and its body</li>
  <li>an algebraic data type (case class) its alternatives and fields</li>
</ul>

<p>it is a map data structure</p>

<h3 id="scope-and-scoping-rules">scope and scoping rules</h3>

<h4 id="static-lexical-scoping">static (lexical) scoping</h4>

<p>local variables are only visible inside the function or block where they are introduced</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_22-33-49.png" alt="" /></p>

<h2 id="type-system">type system</h2>

<p>why type? prevent errors, ensure memory safety, document the program, refactor, compilation optimization</p>

<p>An unsound (broken) type system</p>

<h3 id="background-inductively-defined-relations-and-sets">background: inductively defined relations and sets</h3>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_22-49-13.png" style="zoom:60%;" /></p>

<table>
  <tbody>
    <tr>
      <td>proof that r = {(x, y)</td>
      <td>x &lt;= y}:</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>if there is a derivation, then x&lt;=y</p>

    <ul>
      <li>induction on derivation, go through each rule</li>
    </ul>
  </li>
  <li>
    <p>if x&lt;=y, there exists a derivation</p>

    <ul>
      <li>
        <p>given x, y find derivation tree</p>

        <p>start from (0, 0) then derive (0, y-x) in y-x steps of increase right</p>

        <table>
          <tbody>
            <tr>
              <td>if x &gt; 0, increase both, x &lt; 0, decrease both</td>
              <td>x</td>
              <td>times</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/images/compiler/Snipaste_2021-12-10_22-50-12.png" style="zoom:60%;" /></p>

<h3 id="context-free-grammar-as-inductively-defined-relations">context-free grammar as inductively defined relations</h3>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_14-27-28.png" style="zoom:60%; float: left" /></p>

<p>We define a rule as r of the form
\(\frac{t_1(\bar x) \in r, ... , t_n(\bar x) \in r}{t(\bar x) \in r}\)
where t~i~(x) in r is the assumptions, and t(x) in r is the conclusion</p>

<p>when n=0 (no assumptions), the rule is called an axiom</p>

<h4 id="example-amyli-language">example: Amyli language</h4>

<p>Amyli is a tiny language only works on integers and booleans</p>

<p>(initial) program is a pair (e~top~, t~top~) where</p>

<ul>
  <li>e~top~ is the top-level environment, function names -&gt; function definition</li>
  <li>t~top~ is the top-level term (expression) that starts execution</li>
</ul>

<p>Function definition for a given function name is a tuple of:</p>

<ul>
  <li>parameter list $\bar x$</li>
  <li>parameter type $\bar \tau$</li>
  <li>expression representing function body t</li>
  <li>result type $\tau_0$</li>
</ul>

<p>expressions are formed by primitive functions (+, -, *, /), defined function calls or if expression</p>

<p>no local val definition nor match, e will remain fixed</p>

<p>thus, we can write t as:
\(t := true \mid false \mid c \mid f(t_1, t_2, ..., t_n) \mid if (t) ~t_1 ~else ~t_2
\\ \text{c is an interger, f denotes user-defined function or primitive operators}\)
so we can write a simple factor function program as:</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_14-45-18.png" style="zoom: 50%;" /></p>

<h4 id="operational-semantics">operational semantics</h4>

<p>so how can we process a program to infer its type? We need to define a set of rules so that we can define the relations inductively:</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_14-51-31.png" style="zoom:50%;" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_14-51-42.png" style="zoom: 50%;" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_14-51-51.png" style="zoom: 50%;" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_14-52-29.png" style="zoom: 50%;" /></p>

<p>having these rules, we can do the induction:</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_15-05-24.png" style="zoom:50%;" /></p>

<p>now consider another example, when we encounter a expression: if (5) 3 else 7</p>

<p>5 cannot further evaluate and it is a integer constant, but if statement only accepts true, false, thus it get <strong>stuck</strong></p>

<p><strong>stuck</strong> terms indicate errors</p>

<p><strong>Type checking</strong> is a way to prevent stuck terms <strong>statically</strong>, without trying to evaluate the program to see if it gets stuck</p>

<h4 id="typing-rules">typing rules</h4>

<p>typing context: given inital program (e, t) defined
\(\Gamma_0 = \set{(f, \tau_1 \times...\times\tau_n\to \tau_0)\mid (f, xs, (\tau_1,...,\tau_n), t_f, \tau_0)\in e}\)
<img src="/assets/images/compiler/Snipaste_2021-12-12_15-16-02.png" style="zoom:60%;float:left" /></p>

<p>now we can set the type rules for the Amyli language:</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_15-21-23.png" style="zoom:50%;float:left" /></p>

<h4 id="soundness-theorem">soundness theorem</h4>

<p>if program type checks, its evaluation does not get stuck</p>

<p>proof using two lemmas (common approach):</p>

<ul>
  <li>
    <p>progress</p>

    <p>if a program type checks, it is not stuck.</p>

    <p>if $\Gamma \vdash t:\tau$, then either t is a constant or there exists a t’ that $t  \rightsquigarrow t’$</p>
  </li>
  <li>
    <p>preservation</p>

    <p>if a program type checks and makes one “$ \rightsquigarrow$” step, then the result again type checks.</p>

    <p>e.g. if $\Gamma \vdash t:\tau$ and $t\rightsquigarrow t’$ then $\Gamma \vdash t’:\tau$</p>
  </li>
</ul>

<p>example: how to show that if is progress and preservation</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_15-32-55.png" style="zoom: 50%;" /></p>

<p>don’t ask me why, I cannot understand this fucking tedious proof</p>

<p>an example of derivation tree:</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_15-37-38.png" style="zoom:50%;" /></p>

<h2 id="type-inference">type inference</h2>

<p>motivation:</p>

<p>writing type annotations is boring, need a way to get the type automatically</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_15-41-57.png" style="zoom:50%;" /></p>

<p>then how to do a type inference? think about one small example:</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_15-44-14.png" style="zoom:50%;" /></p>

<h3 id="strategy-for-type-inference">strategy for type inference</h3>

<ol>
  <li>use type variable (e.g. $\alpha_{verbose}, \alpha_{s}$) to denote unknown types</li>
  <li>use type checking rules to derive constraints among type variables (e.g., arguments have expected types)</li>
  <li>use a unification algorithm to solve the constraints</li>
</ol>

<h3 id="demo-using-a-simple-language">demo using a simple language</h3>

<h4 id="types">types</h4>

<ol>
  <li>primitive types: Int, Bool, String, Unit</li>
  <li>type constructors: Pair[A, B] or (A, B), Function[A,B] or A=&gt;B</li>
</ol>

<p>Abstract syntax of types:
\(T ::= Int \mid Bool \mid String \mid Unit \mid (T_1, T_2) \mid (T_1, \Rightarrow T_2)\)
Terms include pairs and anonymous functions: (x denotes variables, c literals)
\(t ::= x \mid c \mid f(t_1,...,t_n) \mid if (t) ~ t_1 ~ else ~ t_2 \mid (t1,t2) \mid (x \Rightarrow t)\)
if t= (x,y) then t._1=x and t._2=y</p>

<h4 id="type-rules">type rules</h4>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_16-05-53.png" style="zoom: 50%; float: left;" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_16-06-03.png" style="zoom:50%;float:left" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_16-06-16.png" style="zoom:50%;float:left" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_16-07-20.png" style="zoom:50%;float:left" /></p>

<p>now let’s see an example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">translatorFactory</span><span class="o">(</span><span class="n">dx</span><span class="o">,</span> <span class="n">dy</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
	<span class="n">p</span><span class="o">⇒(</span><span class="nv">p</span><span class="o">.</span><span class="py">_1</span> <span class="o">+</span> <span class="n">dx</span><span class="o">,</span> <span class="nv">p</span><span class="o">.</span><span class="py">_2</span> <span class="o">+</span> <span class="n">dy</span><span class="o">)</span><span class="c1">// returns anonymous function</span>
<span class="o">}</span>
<span class="k">def</span> <span class="nf">upTranslator</span> <span class="k">=</span> <span class="nf">translatorFactory</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">test</span> <span class="k">=</span> <span class="nf">upTranslator</span><span class="o">((</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span> <span class="c1">// computes (3, 105)</span>

<span class="c1">// the actual type should be:</span>
<span class="k">def</span> <span class="nf">translatorFactory</span><span class="o">(</span><span class="n">dx</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">dy</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span><span class="kt">Int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nc">Int</span><span class="o">,</span><span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
	<span class="n">p</span><span class="o">⇒(</span><span class="nv">p</span><span class="o">.</span><span class="py">_1</span> <span class="o">+</span> <span class="n">dx</span><span class="o">,</span> <span class="nv">p</span><span class="o">.</span><span class="py">_2</span> <span class="o">+</span> <span class="n">dy</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">def</span> <span class="nf">upTranslator</span> <span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span><span class="kt">Int</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nc">Int</span><span class="o">,</span><span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nf">translatorFactory</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">test</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nf">upTranslator</span><span class="o">((</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
</code></pre></div></div>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_16-21-16.png" style="zoom:67%;" /></p>

<p>So, when we don’t have the type, how can we inference the type, say dx?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">translatorFactory</span><span class="o">(</span><span class="n">dx</span><span class="o">,</span> <span class="n">dy</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="n">p</span><span class="o">⇒(</span><span class="nv">p</span><span class="o">.</span><span class="py">_1</span> <span class="o">+</span> <span class="n">dx</span><span class="o">,</span> <span class="nv">p</span><span class="o">.</span><span class="py">_2</span> <span class="o">+</span> <span class="n">dy</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div></div>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_16-35-16.png" style="zoom: 50%;" /></p>

<p>so, we can generate constraints from the expressions given:</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_16-37-30.png" style="zoom:67%;" /></p>

<p>then, we need a unification algorithm to solve the constraints:</p>

<ul>
  <li>
    <p>Apply following rules as long as current set of equations changes:</p>

    <ul>
      <li>
        <p>Orient: Replace T=αwithα=T when T not a type variable</p>
      </li>
      <li>
        <p>Delete useless: Remove T=T (both sides syntactically equal)</p>
      </li>
      <li>
        <p>Eliminate: Givenα=T whereαdoes not occur in T,</p>
      </li>
      <li>
        <p>replaceαwith T in all remaining equations</p>
      </li>
      <li>
        <p>Occurs check: Givenα=T whereαoccurs in T, report error (no solutions)</p>
      </li>
      <li>
        <p>Decompose pairs: Replace(T1,T2) = (T′1,T′2)with T1=T′1and T2=T′2</p>
      </li>
      <li>
        <p>Decompose functions: Replace(T1⇒T2) = (T′1⇒T′2)with T1=T′1and T2=T′2.</p>
      </li>
      <li>
        <p>Decomposition clash (remaining cases): Given T1=T2 where T1and T2have different constructors, report clash (no solution)</p>

        <p>Examples:(T1,T2) = (T′1⇒T′2); Int= (T1,T2); Int=Bool;(T1⇒T2) =String</p>
      </li>
    </ul>
  </li>
  <li>
    <p>property of unification algorithm</p>

    <ul>
      <li>always terminated</li>
      <li>If error reported, equations have no solution</li>
      <li>otherwise, it has one or more solutions</li>
    </ul>
  </li>
</ul>

<h2 id="code-generation">code generation</h2>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_19-09-25.png" style="zoom:50%;" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_19-11-13.png" style="zoom:50%;" /></p>

<p>the specification for Web Assembly is at this link <a href="https://webassembly.github.io/spec/core/exec/index.html">here</a></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_19-10-51.png" style="zoom:50%;" /></p>

<p>a stack machine simulator could be:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">code</span> <span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Instruction</span><span class="o">]</span>
<span class="k">var</span> <span class="n">pc</span> <span class="k">:</span> <span class="kt">Int</span> <span class="c1">// program counter</span>
<span class="k">var</span> <span class="n">local</span> <span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>  <span class="c1">// for local variables</span>
<span class="k">var</span> <span class="n">operand</span> <span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>  <span class="c1">// operand stack</span>
<span class="k">var</span> <span class="n">top</span> <span class="k">:</span> <span class="kt">Int</span>
<span class="nf">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> 
	<span class="n">step</span>
    <span class="k">def</span> <span class="nf">step</span> <span class="k">=</span> <span class="nf">code</span><span class="o">(</span><span class="n">pc</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Iadd</span><span class="o">()</span> <span class="k">=&gt;</span>
            <span class="nf">operand</span><span class="o">(</span><span class="n">top</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="nf">operand</span><span class="o">(</span><span class="n">top</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="nf">operand</span><span class="o">(</span><span class="n">top</span><span class="o">)</span>
            <span class="n">top</span> <span class="k">=</span> <span class="n">top</span> <span class="err">­</span> <span class="mi">1</span>  <span class="c1">// two consumed, one produced</span>
        <span class="k">case</span> <span class="nc">Imul</span><span class="o">()</span> <span class="k">=&gt;</span> 
            <span class="nf">operand</span><span class="o">(</span><span class="n">top</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="nf">operand</span><span class="o">(</span><span class="n">top</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="nf">operand</span><span class="o">(</span><span class="n">top</span><span class="o">)</span>
            <span class="n">top</span> <span class="k">=</span> <span class="n">top</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// two consumed, one produced</span>
        <span class="k">case</span> <span class="nf">iconst</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nf">operand</span><span class="o">(</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="n">c</span> <span class="c1">// put given constant 'c' onto stack</span>
            <span class="n">top</span> <span class="k">=</span> <span class="n">top</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">case</span> <span class="nc">Igetlocal</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> 
            <span class="nf">operand</span><span class="o">(</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="nf">local</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="c1">// from memory onto stack</span>
            <span class="n">top</span> <span class="k">=</span> <span class="n">top</span> <span class="o">+</span> <span class="mi">1</span> 
        <span class="k">case</span> <span class="nc">Isetlocal</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> 
            <span class="nf">local</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=</span> <span class="nf">operand</span><span class="o">(</span><span class="n">top</span><span class="o">)</span> <span class="c1">// from stack into memory</span>
            <span class="n">top</span> <span class="k">=</span> <span class="n">top</span> <span class="err">­</span> <span class="mi">1</span>  <span class="c1">// consumed</span>
        <span class="o">}</span>
	<span class="nf">if</span> <span class="o">(</span><span class="nf">notJump</span><span class="o">(</span><span class="nf">code</span><span class="o">(</span><span class="n">n</span><span class="o">)))</span>
		<span class="n">pc</span> <span class="k">=</span> <span class="n">pc</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1">// by default go to next instructions</span>
</code></pre></div></div>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_19-27-41.png" style="zoom:67%;" /></p>

<h3 id="prefix-postfix-infix-notation">prefix, postfix, infix notation</h3>

<p>let f be a binary operation, e~1~, e~2~ two expressions</p>

<ul>
  <li>in prefix, f e~1~ e~2~, Polish notation</li>
  <li>in infix, e~1~ f e~2~</li>
  <li>in postfix, e~1~ e~2~ f Reverse Polish notation (RPN)</li>
</ul>

<p>for nested expressions, like a * b + c, infix needs parentheses, prefix and postfix no bracket</p>

<table>
  <thead>
    <tr>
      <th>arg.list</th>
      <th>+(x,y)</th>
      <th>+(*(x,y),z)</th>
      <th>+(x,*(y,z))</th>
      <th>*(x,+(y,z))</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>prefix</td>
      <td>+ x y</td>
      <td>+ * x y z</td>
      <td>+ x * y z</td>
      <td>* x + y z</td>
    </tr>
    <tr>
      <td>infix</td>
      <td>x+y</td>
      <td>x*y + z</td>
      <td>x + y*z</td>
      <td>x*(y+z)</td>
    </tr>
    <tr>
      <td>postfix</td>
      <td>x y +</td>
      <td>x y * z +</td>
      <td>x y z * +</td>
      <td>x y z + **</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>prefix</th>
      <th>+ + + x y z u</th>
      <th>+ x + y + z u</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>infix</td>
      <td>((x + y) + z) + u</td>
      <td>x + (y + (z + u))</td>
    </tr>
    <tr>
      <td>postfix</td>
      <td>x y + z + u +</td>
      <td>x y z u + + +</td>
    </tr>
  </tbody>
</table>

<p>first draw the AST, and then traverse according to the order</p>

<p>below is an example to transform a tree into a prefix, postfix and infix notation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">enum</span> <span class="nc">Expr</span><span class="k">:</span>
    <span class="kt">case</span> <span class="kt">Var</span><span class="o">(</span><span class="kt">varID:</span> <span class="kt">String</span><span class="o">)</span>
    <span class="kt">case</span> <span class="kt">Plus</span><span class="o">(</span><span class="kt">lhs:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="kt">rhs:</span> <span class="kt">Expr</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Times</span><span class="o">(</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">rhs</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span>

<span class="n">enum</span> <span class="nc">Token</span><span class="k">:</span>
    <span class="kt">case</span> <span class="kt">ID</span><span class="o">(</span><span class="kt">str</span> <span class="kt">:</span> <span class="kt">String</span><span class="o">)</span>
    <span class="kt">case</span> <span class="kt">Add</span>
    <span class="k">case</span> <span class="nc">Mul</span>
    <span class="k">case</span> <span class="n">O</span> <span class="c1">// Opening paren ’(’</span>
    <span class="k">case</span> <span class="n">C</span> <span class="c1">// Closing paren ’)’</span>

<span class="k">def</span> <span class="nf">prefix</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Token</span><span class="o">]</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span>
    <span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="nc">ID</span><span class="o">(</span><span class="n">id</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">Plus</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span><span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Add</span><span class="o">())</span> <span class="o">:::</span> <span class="nf">prefix</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">:::</span> <span class="nf">prefix</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Times</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span><span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Mul</span><span class="o">())</span> <span class="o">:::</span> <span class="nf">prefix</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">:::</span> <span class="nf">prefix</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">infix</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Token</span><span class="o">]</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="c1">// needs to emit parantheses</span>
    <span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="nc">ID</span><span class="o">(</span><span class="n">id</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">Plus</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span><span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span>
    	<span class="nc">List</span><span class="o">(</span><span class="nf">O</span><span class="o">())</span> <span class="o">:::</span> <span class="nf">infix</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Add</span><span class="o">())</span> <span class="o">:::</span> <span class="nf">infix</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="o">:::</span><span class="nc">List</span><span class="o">(</span><span class="nf">C</span><span class="o">())</span>
    <span class="k">case</span> <span class="nc">Times</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span><span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">List</span><span class="o">(</span><span class="nf">O</span><span class="o">())</span> <span class="o">:::</span> <span class="nf">infix</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Mul</span><span class="o">())</span> <span class="o">:::</span> <span class="nf">infix</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="o">:::</span><span class="nc">List</span><span class="o">(</span><span class="nf">C</span><span class="o">())</span>

<span class="k">def</span> <span class="nf">postfix</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Token</span><span class="o">]</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span>
    <span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="nc">ID</span><span class="o">(</span><span class="n">id</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">Plus</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span><span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">postfix</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">:::</span> <span class="nf">postfix</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Add</span><span class="o">())</span>
    <span class="k">case</span> <span class="nc">Times</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span><span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">postfix</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">:::</span> <span class="nf">postfix</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Mul</span><span class="o">())</span>
</code></pre></div></div>

<p>Lisp, an example of prefix notation</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defun</span> <span class="nv">factorial</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
		<span class="mi">1</span>
		<span class="p">(</span><span class="nb">*</span> <span class="nv">n</span> <span class="p">(</span><span class="nv">factorial</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>
</code></pre></div></div>

<p>Postscript, an example of post fix language</p>

<div class="language-postscript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">/inch</span> <span class="p">{</span><span class="mf">72</span> <span class="nb">mul</span><span class="p">}</span> <span class="nb">def</span>
<span class="nv">/wedge</span>
    <span class="p">{</span> <span class="nb">newpath</span>
        <span class="mf">0</span> <span class="mf">0</span> <span class="nb">moveto</span>
        <span class="mf">1</span> <span class="mf">0</span> <span class="nb">translate</span>
        <span class="mf">15</span> <span class="nb">rotate</span>
        <span class="mf">0</span> <span class="mf">15</span> <span class="nb">sin</span> <span class="nb">translate</span>
        <span class="mf">0</span> <span class="mf">0</span> <span class="mf">15</span> <span class="nb">sin</span> <span class="nf">-</span> <span class="mf">90</span> <span class="mf">90</span> <span class="nb">arc</span>
        <span class="nb">closepath</span>
    <span class="p">}</span> <span class="nb">def</span>
<span class="nb">gsave</span>
    <span class="mf">3.75</span> <span class="nf">inch</span> <span class="mf">7.25</span> <span class="nf">inch</span> <span class="nb">translate</span>
    <span class="mf">1</span> <span class="nf">inch</span> <span class="mf">1</span> <span class="nf">inch</span> <span class="nb">scale</span>
    <span class="nf">wedge</span> <span class="mf">0.02</span> <span class="nb">setlinewidth</span> <span class="nb">stroke</span>
<span class="nb">grestore</span>
<span class="nb">gsave</span>
</code></pre></div></div>

<h3 id="compiling-expression">compiling expression</h3>

<p>why postfix? can evaluate it using stack</p>

<ul>
  <li>Evaluating postfix expressions is like running a stack based virtual machine on compiled code</li>
  <li>Compiling expressions for stack machine is like translating expressions into postfix form</li>
</ul>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_21-00-14.png" style="zoom:50%;" /></p>

<p>to evaluate e1 * e2 interpret as:</p>

<ul>
  <li>evaluate e1</li>
  <li>evaluate e2</li>
  <li>combines the result using *</li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">compile</span><span class="o">(</span><span class="n">e</span> <span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Bytecode</span><span class="o">]</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span> <span class="c1">// ~ postfix printer</span>
    <span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Igetlocal</span><span class="o">(</span><span class="nf">slotFor</span><span class="o">(</span><span class="n">id</span><span class="o">)))</span>
    <span class="k">case</span> <span class="nc">Plus</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span><span class="n">e2</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="nf">compile</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">:::</span> <span class="nf">compile</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Iadd</span><span class="o">())</span>
    <span class="k">case</span> <span class="nc">Times</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span><span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">compile</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">:::</span> <span class="nf">compile</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Imul</span><span class="o">())</span>   
<span class="o">}</span>
</code></pre></div></div>

<p>to include local variables:</p>

<ul>
  <li>Assigning indices (called slots) to local variables using function 
	slotOf : VarSymbol -&gt; {0,1,2,3,…}</li>
  <li>How to compute the indices?</li>
  <li>assign them in the order in which they appear in the tree</li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">compile</span><span class="o">(</span><span class="n">e</span> <span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Bytecode</span><span class="o">]</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Igetlocal</span><span class="o">(</span><span class="nf">slotFor</span><span class="o">(</span><span class="n">id</span><span class="o">)))</span>
	<span class="o">...</span>	
<span class="o">}</span>
<span class="k">def</span> <span class="nf">compileStmt</span><span class="o">(</span><span class="n">s</span> <span class="k">:</span> <span class="kt">Statmt</span><span class="o">)</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Bytecode</span><span class="o">]</span> <span class="k">=</span> <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
	<span class="c1">// id=e</span>
	<span class="k">case</span> <span class="nc">Assign</span><span class="o">(</span><span class="n">id</span><span class="o">,</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">compile</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Iset_local</span><span class="o">(</span><span class="nf">slotFor</span><span class="o">(</span><span class="n">id</span><span class="o">)))</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_21-20-33.png" style="zoom:50%;" /></p>

<p>compiling control flow:</p>

<p>in Web Assembly, All comparison operators yield 32­bit integer results with 1 representing true and 0 representing false.</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_21-33-37.png" style="zoom:67%;" /></p>

<ul>
  <li>block: the beginning of a block construct, a sequence of instructions with a label at the end</li>
  <li>loop: a block with a label at the beginning which may be used to form loops</li>
  <li>br: branch to a given label in an enclosing construct</li>
  <li>br_if: conditionally branch to a given label in an enclosing construct</li>
  <li>return: return zero or more values from this function</li>
  <li>end: an instruction that marks the end of a block, loop, if, or function</li>
</ul>

<pre><code class="language-assembly">block $label1 block $label0
(negated condition code)
br_if $label0 // to else branch
(true case code)
br $label1// done with if
end $label0// else branch
(false case code)
end $label1// end of if
</code></pre>

<p>or, in web assembly, it provides a shortcut as:</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_21-39-10.png" style="zoom:50%;float:left" /></p>

<p>special tricks for [e1] &amp;&amp; [e2]:</p>

<table>
  <tbody>
    <tr>
      <td>only need to evluate e1 when e1 == False, similarly for [e1]</td>
      <td> </td>
      <td>[e2] when e1 == True</td>
    </tr>
  </tbody>
</table>

<pre><code class="language-assembly">[if (econd) ethenelse eelse] :=
	block nAfter
    	block nElse
    		block nThen
    			branch(econd, nThen, nElse)
    		end //nThen:
    		[ethen]
    		br nAfter
    	end //nElse:
    	[eelse]
    end //nAfter:
    [erest]

branch(!e,nThen,nElse) :=
	branch(e,nElse,nThen)

branch(e1 &amp;&amp; e2,nThen,nElse) :=
	block nLong
		branch(e1,nLong,nElse)
	end //nLong:
	branch(e2,nThen,nElse)

branch(e1 || e2,nThen,nElse) :=
	block nLong
		branch(e1,nThen,nLong)
	end //nLong:
	branch(e2,nThen,nElse)
	
branch(true,nThen,nElse) :=
	br nThen

branch(false,nThen,nElse) :=
	br nElse

branch(b,nThen,nElse) :=	(where b is a local var)
	get_local #b
	br_if nThen
	br nElse
</code></pre>

<p>we can make a new command as :</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_22-36-30.png" style="zoom:50%;" /></p>

<p>then switch statement could write as:</p>

<pre><code class="language-assembly">[sswitch] nAfter nBreak :=
block nDefault
	block nCasen
		...
		block nCase1
			block nTest
				[e_scrutinee] nTest nBreak
			end //nTest:
			tee_local #s(where s is some fresh local of type i32)
			i32.const c1
			i32.eq
			br_if nCase1
			get_local #s
			i32.const c2
			i32.eq
			br_if nCase2
			...
			br nDefault
		end //nCase1:
		[e1] nCase2 nAfter
		...
	end //nCasen:
	[en] nDefault nAfter
end //nDefault:
[edefault] nAfter nAfter
</code></pre>

<h2 id="register-optimization">register optimization</h2>

<p>Basic Instructions of Register Machines
Ri← Mem[Rj]	load
Mem[Rj] ←Ri	store
Ri← Rj * Rk	  compute: for an operation *
Efficient register machine code uses as few loads and stores as possible.</p>

<p>wab assembly: imul.32</p>

<p>register machine: R1 ← Mem[SP]	SP = SP + 4	R2 ← Mem[SP]	R2 ← R1 * R2	Mem[SP] ← R2</p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-12_22-58-51.png" style="zoom:67%;" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-13_14-17-17.png" style="zoom:60%;" /></p>

<p><img src="/assets/images/compiler/Snipaste_2021-12-13_14-18-02.png" style="zoom:60%;" /></p>]]></content><author><name>Wilson ZOU</name></author><category term="cs" /><summary type="html"><![CDATA[compiler is a very important course as a CS student, though my performance is bad in this course, I do not regret to take it...]]></summary></entry><entry><title type="html">My recommendation for 15 chrome extensions</title><link href="https://yzouag.github.io/tech/chrome-extensions/" rel="alternate" type="text/html" title="My recommendation for 15 chrome extensions" /><published>2021-11-11T00:00:00+00:00</published><updated>2021-11-11T00:00:00+00:00</updated><id>https://yzouag.github.io/tech/chrome-extensions</id><content type="html" xml:base="https://yzouag.github.io/tech/chrome-extensions/"><![CDATA[<h1 id="前言">前言</h1>

<p>Google Chrome 是我用的最多的浏览器。一是因为对google账户的支持和同步，我的很多的密码，以及平时用google email注册登录的网站都需要谷歌来管理，二是因为它支持的各种extensions。这里就介绍几个我常用的extensions吧。</p>

<h2 id="1-adblock-plus---free-ad-blocker">1. Adblock Plus - free ad blocker</h2>

<p>chrome必备插件，虽然现在已经被很多网站反屏蔽了，但是在针对youtube的时候特别好用，没有广告的youtube就是最好的影片分享网站。在浏览其他网页的时候，也能让你清净不少，强推！！！</p>

<h2 id="2-adobe-acrobat">2. Adobe Acrobat</h2>

<p>这个是优化Chrome的pdf浏览体验的。chrome自带的pdf预览器，没有outline也没有标注功能。这个插件不仅补足了这些缺憾，还同时可以将笔记存储在adobe的云上，笔记不会丢失也不必保存在本地。我有的时候需要用学校图书馆的电脑，notes就不需要专门用google doc传送了。这个插件还可以和本身的adobe reader相互配合，共享云文档，推荐！</p>

<p><img src="/assets/images/chrome_extensions/adobe.png" alt="" /></p>

<h2 id="3-better-history">3. Better History</h2>

<p>chrome的浏览历史总是不够好看，同时各种搜索支持都不太好。Better history会覆盖掉原本的历史页面，赋予更好看的UI界面和更加强大有条理的历史排序与搜索功能，可以轻松的找到几天前偶然打开的网站。
<img src="/assets/images/chrome_extensions/better_history.png" alt="" /></p>

<h2 id="4-crosspilot">4. CrossPilot</h2>

<p>可以下载youtube视频。</p>

<h2 id="5-global-speed">5. Global Speed</h2>

<p>调节所有网页上播放视频的速度，最高可以到16倍，同时每一级的调节也更加精细了。统一的快捷键设置，也让你在浏览不同视频网站的时候，可以用同一种快捷键调节速度。尤其是网课的视频，网络播放器一般只有三四种速度的选择，这个插件能帮助我在该快的时候快，该慢下来仔细听的地方就慢下来。
<img src="/assets/images/chrome_extensions/global_speed.png" alt="" /></p>

<h2 id="6-mercury-reader">6. Mercury Reader</h2>

<p>网站总是有很多弹窗广告，链接等等，同时网站自己的排版有时候也有些花里胡哨。这个插件能去除掉这些干扰，转换成类似于pdf的干净风格。让人能够静心专注于文字，还是很实用的。
<img src="/assets/images/chrome_extensions/mercury_reader.png" alt="" /></p>

<h2 id="7-grammarly-for-chrome">7. Grammarly for Chrome</h2>

<p>可以帮忙检查很多输入框的语法拼写，替换同义词和指出长句子的语法问题。像我这种英语菜鸡真的是很需要。</p>

<h2 id="8-onetab">8. OneTab</h2>

<p>找到了几个有用的网站，暂时关浏览器但是又不想把网页收进书签。这时候只要轻轻一点插件，所有网站就被收纳起来，同时也能把网页分成几个类分开保存，就和chrome本身的group一样，一部分是学习的，一部分是项目的，一部分是娱乐的等等。
<img src="/assets/images/chrome_extensions/onetab.png" alt="" /></p>

<h2 id="9-saladict">9. Saladict</h2>

<p>最最最好用的字典，打开很方便，拥有非常多种词典的API，同时一直有人维护更新。上网查文献，看pdf等等的时候，可以轻松点开词典，还有划词功能。几个词典之间也能够互相对比，找到更多的例句和更准确的解释，强烈推荐！
<img src="/assets/images/chrome_extensions/saladict.png" alt="" /></p>

<h2 id="10-singlefile">10. SingleFile</h2>

<p>将当前网页保存成一个html文件，非常实用的功能，看到一些文章可以通过这个方式下载下来，同时还能保证它的格式不会改变。</p>

<h2 id="11-ufunr">11. UfunR</h2>

<p>从海外翻回去的梯子，免费，网速稳定。一般来说，网站只会在一开始的时候验证一次地区，所以可以暂时点开UfunR，等到视频/音乐可以听之后，再停止UfunR，保证网速不会太慢</p>

<h2 id="12-veeevpn">12. VeeeVPN</h2>

<p>梯子，没啥可说的，我用的也不多，真的不好评价好坏，装在chrome里的好处是这样只有浏览器翻墙，其他的程序还是保持在墙内的状态。</p>

<h2 id="13-zotero-connector">13. Zotero Connector</h2>

<p>这是和我的Zotero配合使用的，有一些网站觉得很重要，比如是某个工具，某个知识点的介绍网站的时候，可以点击这个加入文库管理，这样在查找本地文献的时候也能被搜索到啦。</p>

<h2 id="14-google-scholar">14. Google Scholar</h2>

<p>只是让你更快的点开它，有时候找引用还是挺方便的</p>

<h2 id="15-return-youtube-dislikes">15. Return YouTube Dislikes</h2>

<p>YouTube现在看不到差评数量了，但是这个插件能让你重新看到它。什么，你问我这有什么用？除了满足一些内心阴暗的想法，硬要说实用性的话，就是在找一些测评或者tutorial的视频的时候，知道它究竟受不受欢迎吧。</p>]]></content><author><name>Wilson ZOU</name></author><category term="tech" /><summary type="html"><![CDATA[前言 Google Chrome 是我用的最多的浏览器。一是因为对google账户的支持和同步，我的很多的密码，以及平时用google email注册登录的网站都需要谷歌来管理，二是因为它支持的各种extensions。这里就介绍几个我常用的extensions吧。 1. Adblock Plus - free ad blocker chrome必备插件，虽然现在已经被很多网站反屏蔽了，但是在针对youtube的时候特别好用，没有广告的youtube就是最好的影片分享网站。在浏览其他网页的时候，也能让你清净不少，强推！！！ 2. Adobe Acrobat 这个是优化Chrome的pdf浏览体验的。chrome自带的pdf预览器，没有outline也没有标注功能。这个插件不仅补足了这些缺憾，还同时可以将笔记存储在adobe的云上，笔记不会丢失也不必保存在本地。我有的时候需要用学校图书馆的电脑，notes就不需要专门用google doc传送了。这个插件还可以和本身的adobe reader相互配合，共享云文档，推荐！ 3. Better History chrome的浏览历史总是不够好看，同时各种搜索支持都不太好。Better history会覆盖掉原本的历史页面，赋予更好看的UI界面和更加强大有条理的历史排序与搜索功能，可以轻松的找到几天前偶然打开的网站。 4. CrossPilot 可以下载youtube视频。 5. Global Speed 调节所有网页上播放视频的速度，最高可以到16倍，同时每一级的调节也更加精细了。统一的快捷键设置，也让你在浏览不同视频网站的时候，可以用同一种快捷键调节速度。尤其是网课的视频，网络播放器一般只有三四种速度的选择，这个插件能帮助我在该快的时候快，该慢下来仔细听的地方就慢下来。 6. Mercury Reader 网站总是有很多弹窗广告，链接等等，同时网站自己的排版有时候也有些花里胡哨。这个插件能去除掉这些干扰，转换成类似于pdf的干净风格。让人能够静心专注于文字，还是很实用的。 7. Grammarly for Chrome 可以帮忙检查很多输入框的语法拼写，替换同义词和指出长句子的语法问题。像我这种英语菜鸡真的是很需要。 8. OneTab 找到了几个有用的网站，暂时关浏览器但是又不想把网页收进书签。这时候只要轻轻一点插件，所有网站就被收纳起来，同时也能把网页分成几个类分开保存，就和chrome本身的group一样，一部分是学习的，一部分是项目的，一部分是娱乐的等等。 9. Saladict 最最最好用的字典，打开很方便，拥有非常多种词典的API，同时一直有人维护更新。上网查文献，看pdf等等的时候，可以轻松点开词典，还有划词功能。几个词典之间也能够互相对比，找到更多的例句和更准确的解释，强烈推荐！ 10. SingleFile 将当前网页保存成一个html文件，非常实用的功能，看到一些文章可以通过这个方式下载下来，同时还能保证它的格式不会改变。 11. UfunR 从海外翻回去的梯子，免费，网速稳定。一般来说，网站只会在一开始的时候验证一次地区，所以可以暂时点开UfunR，等到视频/音乐可以听之后，再停止UfunR，保证网速不会太慢 12. VeeeVPN 梯子，没啥可说的，我用的也不多，真的不好评价好坏，装在chrome里的好处是这样只有浏览器翻墙，其他的程序还是保持在墙内的状态。 13. Zotero Connector 这是和我的Zotero配合使用的，有一些网站觉得很重要，比如是某个工具，某个知识点的介绍网站的时候，可以点击这个加入文库管理，这样在查找本地文献的时候也能被搜索到啦。 14. Google Scholar 只是让你更快的点开它，有时候找引用还是挺方便的 15. Return YouTube Dislikes YouTube现在看不到差评数量了，但是这个插件能让你重新看到它。什么，你问我这有什么用？除了满足一些内心阴暗的想法，硬要说实用性的话，就是在找一些测评或者tutorial的视频的时候，知道它究竟受不受欢迎吧。]]></summary></entry><entry><title type="html">Build A GitHub Personal Home Page with Jekyll and Minimal Mistake Theme</title><link href="https://yzouag.github.io/tech/build-github-page/" rel="alternate" type="text/html" title="Build A GitHub Personal Home Page with Jekyll and Minimal Mistake Theme" /><published>2021-11-09T00:00:00+00:00</published><updated>2021-11-09T00:00:00+00:00</updated><id>https://yzouag.github.io/tech/build-github-page</id><content type="html" xml:base="https://yzouag.github.io/tech/build-github-page/"><![CDATA[<blockquote>
  <p>本文将简略介绍如何使用GitHub Pages来创建一个免费的静态个人网页。具体将分为三个部分：如何在GitHub上创建个人网页，如何使用minimal mistake主题来美化个人主页，如何使用Jekyll本地调试网页。</p>
</blockquote>

<h2 id="github创建个人主页">GitHub创建个人主页</h2>

<p>具体步骤可参照 <a href="https://docs.github.com/en/pages/quickstart">Quickstart for GitHub Pages</a></p>

<p>简单来说分为三步：</p>

<ol>
  <li>
    <p>新建一个public repository，名字设置为<code class="language-plaintext highlighter-rouge">USERNAME.github.io</code>，如图：</p>

    <p><img src="\assets\images\github_pages\screenshot1.png" alt="" /></p>

    <p>其他设置均可维持default，结果是这样：</p>

    <p><img src="\assets\images\github_pages\screenshot2.png" alt="" /></p>
  </li>
  <li>
    <p>此时你可以选择直接本地init一个repo然后传上去，当然也可以通过<code class="language-plaintext highlighter-rouge">Settings</code>-&gt; <code class="language-plaintext highlighter-rouge">Pages</code> -&gt; <code class="language-plaintext highlighter-rouge">choose a theme</code>，在这里就可以自己挑选一个喜欢的主题然后开始往里面填充内容，如图：</p>

    <p><img src="\assets\images\github_pages\screenshot3.png" alt="" /></p>
  </li>
  <li>
    <p>选择后直接commit changes这时我们的网站就设置完成了，在repo的右下角About，Release等等有一个Environment显示Active，点击进入就能看到我们的网站部署成功了，这个网页默认是<code class="language-plaintext highlighter-rouge">USERNAME.github.io</code>：</p>

    <p><img src="\assets\images\github_pages\screenshot4.png" alt="" /></p>

    <p><img src="\assets\images\github_pages\screenshot5.png" alt="" /></p>
  </li>
</ol>

<p><em>在repository中，现在有两个文件<code class="language-plaintext highlighter-rouge">_config.yaml</code>和<code class="language-plaintext highlighter-rouge">index.md</code>。GitHub使用Jekyll来build网站页面，最终要的一个config文件就是<code class="language-plaintext highlighter-rouge">_config.yml</code>，现在里面设置了theme为XXX，所以我们的网站就有了这个主题的样式。同时我们的main page也不一定是<code class="language-plaintext highlighter-rouge">index.html</code>了，因为Jekyll支持将markdown格式转成网页格式，这将帮助我们更快的编写blog，markdown比起html还是方便很多的。</em></p>

<h2 id="使用minimal-mistake主题">使用Minimal Mistake主题</h2>

<p>完成了以上步骤，我们可以得到一个基础的网站了，免费的域名所有人都能访问到。但是…并不好看啊，而且功能好少，我想要更多的不同的分页面可以跳来跳去，我想要更多的艺术细节和更多不同样式的页面。</p>

<p>那我说，你可以全部自己手写网页，就好像别的各路大神写的精美绝伦的静态网页一样…当然，我是做不到啦，所以还是得嫖别人现成的。我选择的一个主题是<a href="https://mmistakes.github.io/minimal-mistakes/">Minimal Mistake</a>。在官网上你可以看到非常细致的教程，而且作者一直有持续更新，所以不用担心bug或者缺少对新技术的支持。不仅如此，作者也会亲自下场回答问题，所以有不会的也可以写一个issue或者搜索minimal mistake + 问题，网上有很多的解答。</p>

<p>简单来讲，一个最快的方式就是直接Fork他的repo，具体步骤如下：</p>

<ol>
  <li>
    <p>进入<a href="https://github.com/mmistakes/minimal-mistakes">repo</a>,直接点击右上角的fork，对，就在星星旁边，这样你就能得到一个repo</p>

    <p><img src="\assets\images\github_pages\screenshot6.png" alt="" /></p>
  </li>
  <li>
    <p>这时候你可以回头把自己之前的玩具网站删掉，delete那个repo或者重命名，并将现在这个minimal mistake重命名为<code class="language-plaintext highlighter-rouge">USERNAME.github.io</code>这样你就可以获得一个全新的模板：</p>

    <p><img src="\assets\images\github_pages\screenshot7.png" alt="" /></p>
  </li>
</ol>

<p>现在的网页还是空空如也，但是你可以根据quick start guide的tutorial，自己来定制网页了。</p>

<h2 id="使用jekyll本地调试网页">使用Jekyll本地调试网页</h2>

<p>如果说，每次我们改一点点东西，都需要push到GitHub上，等它build好才能看到效果，那速度也太慢了，所以我们可以在本地搭建一个测试环境，这样就只要一个功能完成再push一次，大大节约了我们debug的时间。</p>

<p>这部分内容主要参照<a href="https://jekyllrb.com/docs/">Jekyll Doc</a>编写，有兴趣的朋友也可以直接按照官网的教学来。</p>

<p>因为我害怕环境之间的冲突，所以额外创建了一个WSL2的Ubuntu20.04LTS来搭建这个环境，windows和Mac上可能会有所不同。而且讲道理linux上装这些东西真的方便好多好多…</p>

<ol>
  <li>
    <p>安装prerequisite：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 安装Ruby</span>
<span class="nb">sudo </span>apt-get <span class="nb">install </span>ruby-full build-essential zlib1g-dev
   
<span class="c"># 为避免在root user里安装Ruby Gems，可以把Gems装在home里</span>
<span class="nb">echo</span> <span class="s1">'# Install Ruby Gems to ~/gems'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">echo</span> <span class="s1">'export GEM_HOME="$HOME/gems"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">echo</span> <span class="s1">'export PATH="$HOME/gems/bin:$PATH"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="nb">source</span> ~/.bashrc
   
<span class="c"># 前面都成功的话，就可以install jekyll和bundle了</span>
gem <span class="nb">install </span>jekyll bundler
</code></pre></div>    </div>
  </li>
  <li>
    <p>安装成功之后，就可以在本地build一个Jekyll project了：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># clone 自己的repo</span>
git@github.com:wilson99Z/wilson99Z.github.io.git
   
<span class="c"># 在 http://localhost:4000 上试运行网站</span>
<span class="nb">cd </span>USERNAME.github.io
bundle <span class="nb">exec </span>jekyll serve
   
<span class="c"># 当然，如果想全新创建一个Jekyll project，执行如下命令，此时就会创建一个myblog的project</span>
jekyll new myblog
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="结语">结语</h2>

<p>到此我简单介绍了一下搭建一个Jekyll GitHub Pages，接下来的blogs我会具体介绍minimal mistake的一些具体的网页元素的使用方法。感谢你看到这里，点个赞再走吧&gt;.&lt;</p>]]></content><author><name>Wilson ZOU</name></author><category term="tech" /><summary type="html"><![CDATA[本文将简略介绍如何使用GitHub Pages来创建一个免费的静态个人网页。具体将分为三个部分：如何在GitHub上创建个人网页，如何使用minimal mistake主题来美化个人主页，如何使用Jekyll本地调试网页。 GitHub创建个人主页 具体步骤可参照 Quickstart for GitHub Pages 简单来说分为三步： 新建一个public repository，名字设置为USERNAME.github.io，如图： 其他设置均可维持default，结果是这样： 此时你可以选择直接本地init一个repo然后传上去，当然也可以通过Settings-&gt; Pages -&gt; choose a theme，在这里就可以自己挑选一个喜欢的主题然后开始往里面填充内容，如图： 选择后直接commit changes这时我们的网站就设置完成了，在repo的右下角About，Release等等有一个Environment显示Active，点击进入就能看到我们的网站部署成功了，这个网页默认是USERNAME.github.io： 在repository中，现在有两个文件_config.yaml和index.md。GitHub使用Jekyll来build网站页面，最终要的一个config文件就是_config.yml，现在里面设置了theme为XXX，所以我们的网站就有了这个主题的样式。同时我们的main page也不一定是index.html了，因为Jekyll支持将markdown格式转成网页格式，这将帮助我们更快的编写blog，markdown比起html还是方便很多的。 使用Minimal Mistake主题 完成了以上步骤，我们可以得到一个基础的网站了，免费的域名所有人都能访问到。但是…并不好看啊，而且功能好少，我想要更多的不同的分页面可以跳来跳去，我想要更多的艺术细节和更多不同样式的页面。 那我说，你可以全部自己手写网页，就好像别的各路大神写的精美绝伦的静态网页一样…当然，我是做不到啦，所以还是得嫖别人现成的。我选择的一个主题是Minimal Mistake。在官网上你可以看到非常细致的教程，而且作者一直有持续更新，所以不用担心bug或者缺少对新技术的支持。不仅如此，作者也会亲自下场回答问题，所以有不会的也可以写一个issue或者搜索minimal mistake + 问题，网上有很多的解答。 简单来讲，一个最快的方式就是直接Fork他的repo，具体步骤如下： 进入repo,直接点击右上角的fork，对，就在星星旁边，这样你就能得到一个repo 这时候你可以回头把自己之前的玩具网站删掉，delete那个repo或者重命名，并将现在这个minimal mistake重命名为USERNAME.github.io这样你就可以获得一个全新的模板： 现在的网页还是空空如也，但是你可以根据quick start guide的tutorial，自己来定制网页了。 使用Jekyll本地调试网页 如果说，每次我们改一点点东西，都需要push到GitHub上，等它build好才能看到效果，那速度也太慢了，所以我们可以在本地搭建一个测试环境，这样就只要一个功能完成再push一次，大大节约了我们debug的时间。 这部分内容主要参照Jekyll Doc编写，有兴趣的朋友也可以直接按照官网的教学来。 因为我害怕环境之间的冲突，所以额外创建了一个WSL2的Ubuntu20.04LTS来搭建这个环境，windows和Mac上可能会有所不同。而且讲道理linux上装这些东西真的方便好多好多… 安装prerequisite： # 安装Ruby sudo apt-get install ruby-full build-essential zlib1g-dev # 为避免在root user里安装Ruby Gems，可以把Gems装在home里 echo '# Install Ruby Gems to ~/gems' &gt;&gt; ~/.bashrc echo 'export GEM_HOME="$HOME/gems"' &gt;&gt; ~/.bashrc echo 'export PATH="$HOME/gems/bin:$PATH"' &gt;&gt; ~/.bashrc source ~/.bashrc # 前面都成功的话，就可以install jekyll和bundle了 gem install jekyll bundler 安装成功之后，就可以在本地build一个Jekyll project了： # clone 自己的repo git@github.com:wilson99Z/wilson99Z.github.io.git # 在 http://localhost:4000 上试运行网站 cd USERNAME.github.io bundle exec jekyll serve # 当然，如果想全新创建一个Jekyll project，执行如下命令，此时就会创建一个myblog的project jekyll new myblog 结语 到此我简单介绍了一下搭建一个Jekyll GitHub Pages，接下来的blogs我会具体介绍minimal mistake的一些具体的网页元素的使用方法。感谢你看到这里，点个赞再走吧&gt;.&lt;]]></summary></entry><entry><title type="html">6 PDF Readers Reviews</title><link href="https://yzouag.github.io/tech/pdf_reviews/" rel="alternate" type="text/html" title="6 PDF Readers Reviews" /><published>2021-11-05T00:00:00+00:00</published><updated>2021-11-05T00:00:00+00:00</updated><id>https://yzouag.github.io/tech/pdf_reviews</id><content type="html" xml:base="https://yzouag.github.io/tech/pdf_reviews/"><![CDATA[<h1 id="前言">前言</h1>

<p>pdf阅读器对我来说是非常重要的学习工具，但同时它也仅仅是一个学习工具。对我来说，它的大部分使用场景都是读paper或者是读课件读textbook，白嫖惯了不怎么有买纸质书的习惯。我也有ipad，但是notability用来记笔记我的字太丑，加上每次强迫症画条直线都要半天，标注结束都忘记自己要干嘛了。因此，我对pdf阅读器的要求主要集中在阅读体验和标注的便捷上，对于其他编辑pdf的功能，我暂时并不需要。在大学四年的学习中，我使用过许多的pdf浏览器，在此我把他们的最新版本都重新下载了一遍，也算是重温旧梦吧^_^</p>

<hr />

<h1 id="正文">正文</h1>

<h2 id="1-bookxnote-pro">1. BookxNote Pro</h2>

<figure class="half ">
  
    
      <a href="/assets/images/pdf_review/bookxnote.png" title="BookXnote Pro">
          <img src="/assets/images/pdf_review/bookxnote.png" alt="image for bookxnote" />
      </a>
    
  
    
      <a href="/assets/images/pdf_review/bookxnote1.png" title="BookXnote Pro">
          <img src="/assets/images/pdf_review/bookxnote.png" alt="image for bookxnote" />
      </a>
    
  
  
    <figcaption>Screenshot from BookxNote Pro
</figcaption>
  
</figure>

<ul>
  <li>非常干净的一款pdf阅读器，集成了一个markdown笔记本，同时支持脑图、大纲等功能（可惜我不太喜欢用）</li>
  <li>我对pdf浏览器的一大要求就是文本的占比高，最好能把左右的工具栏页面等等隐藏起来，这款就符合我的要求</li>
  <li>这个reader的工具也基本满足所有需求，同时滑动非常流畅，体验非常丝滑，也没有要登录或者升级的弹窗或者广告</li>
  <li>我用电脑看pdf的另一个要求就是操作越少越好，像是高亮和划线，我希望一旦选中文字，工具框就能跳出来，这样从选中到高亮只需要一次操作，能让我更加专注于文字本身</li>
  <li>这个浏览器还有四种颜色主题，暖色、黑夜模式和护眼模式，我都觉得很漂亮舒适</li>
  <li>写到这完全想不起来自己当时放弃这个pdf浏览器的理由了，可能刚更新2.0所以我之前不喜欢的地方被改正了？让我再用用看……</li>
</ul>

<hr />

<h2 id="2-xodo-pdf-reader">2. Xodo PDF Reader</h2>

<figure class="half ">
  
    
      <a href="/assets/images/pdf_review/xodo.png" title="Xodo image">
          <img src="/assets/images/pdf_review/xodo.png" alt="image for xodo" />
      </a>
    
  
    
      <a href="/assets/images/pdf_review/xodo1.png" title="Xodo image">
          <img src="/assets/images/pdf_review/xodo1.png" alt="image for xodo" />
      </a>
    
  
  
    <figcaption>Screenshot from Xodo
</figcaption>
  
</figure>

<ul>
  <li>我用的时间最长的PDF浏览器了，可以说它塑造了我对这类软件的偏好：非常现代好看的UI，非常便捷简单的标注，同时几乎隐藏所有工具状态栏的zen mode，支持护眼模式。重复一遍，这四点是我个人对pdf浏览器最重要的四个需求</li>
  <li>从图片就可以看出来了，只用最上面薄薄的一个框，内容占比高的惊人，标注也是选中文字就可以点一下要高亮还是下划线了</li>
  <li>xodo还多一个波浪线呢….嘛，虽然可能很多人觉得我在尬吹，但是做笔记的时候多个花纹还是好的呀</li>
  <li>xodo支持一些pdf的其他操作，像是merge，split， remove password等等，但是是付费版的功能，而且我真的只是用来看书看论文，所以还是免了</li>
  <li>这一款的滑动也是很丝滑的，嗯，一直重复这一点就是为了diss adobe acrobat，不知道是我自己的设置问题还是它就是有问题</li>
  <li>放弃它的最主要原因，是启动速度太慢了，同样开一个文件，别的所有浏览器都是一瞬间，只有这一款每次都需要loading好一会儿，并且偶尔还会出现死机闪退的现象，不知道是我个人情况还是真的软件本身问题。嗯，说不定代码内部一直有些问题吧…</li>
  <li>另一个小问题，就是调整页面大小的时候没有fit to width， fit to page的选项，每次只能滑滚调节，强迫症每次看到最后一点白边简直百爪挠心</li>
</ul>

<hr />

<h2 id="3-microsoft-edge浏览器">3. Microsoft Edge浏览器</h2>

<p><img src="\assets\images\pdf_review\edge.png" alt="" /></p>

<p><img src="\assets\images\pdf_review\edge1.png" alt="" /></p>

<ul>
  <li>旧版edge永远滴神~~ 可惜更新了之后拉跨了不少。但作为windows原装的pdf浏览器，已经远超隔壁chrome重度残疾的pdf reader了</li>
  <li>edge的滑动速度是最快的，同时想要打开文件的时候直接把文件往浏览器里拖就可以，对于可以用电脑的开卷考试，绝对能帮你最快找到答案</li>
  <li>edge的另一个优点是可以用插件，嗯，说的就是saladict，看英文书的时候查单词特别方便</li>
  <li>可惜毕竟主要是浏览器而不是pdf阅读器，很多功能还是缺失或者有瑕疵。像是没有颜色主题切换，而且标注的时候，选中 -&gt; 移到高亮 -&gt; 点击颜色，中间多了一个过程。我强迫症，我受不了，哼。</li>
  <li>且不能插入文本框，有时候写一些自己的总结，或者上课做笔记还是不太方便</li>
</ul>

<hr />

<h2 id="4-foxit-pdf-reader-福昕">4. Foxit PDF Reader (福昕)</h2>

<p><img src="\assets\images\pdf_review\foxit.png" alt="" /></p>

<p><img src="\assets\images\pdf_review\foxit1.png" alt="" /></p>

<ul>
  <li>大一的时候使用的pdf浏览器，后来就被旧版edge和ipad给替代了，直到换了新的电脑，就彻底的被遗弃了。今天特地下回来再次体验一下。</li>
  <li>现代化的UI，配色和icon都非常讨人喜欢</li>
  <li>支持非常多的功能，对于想要追求大而全的用户应该很好吧，有点像office全家桶的感觉，工具栏的排布等等</li>
  <li>在read mode的情况下只会剩下边框加上file home的那一栏，也是不错的，但是很多时候会看到右上角忽闪忽闪的广告，有点恼人</li>
  <li>我最需要的标注功能上，选择只有复制和高亮两个，比起前几位就有些少了，不知道是不是能自己手动添加一些</li>
  <li>滚动相对没有这么丝滑，不过我个人最不喜欢的还是太多的功能键会干扰我的思维，尤其是读不进论文的时候，更是会无意义的乱点按钮，这种时候界面越简单越沉得下心</li>
</ul>

<hr />

<h2 id="5-pdf-x-change-editor">5. PDF X-Change Editor</h2>

<p><img src="\assets\images\pdf_review\xchange.png" alt="" /></p>

<ul>
  <li>好吧其实这是一个editor不是reader了，放在这里和其他的比不太公平，但是这是一个免费的强大的pdf editor，所以还是记一下，将来说不定有用</li>
  <li>安装起来毫不流氓，UI也不是10年前的古董graphic设计</li>
</ul>

<hr />

<h2 id="6-adobe-acrobat-pdf">6. Adobe Acrobat PDF</h2>

<p><img src="\assets\images\pdf_review\adobe.png" alt="" /></p>

<p><img src="\assets\images\pdf_review\adobe1.png" alt="" /></p>

<ul>
  <li>pdf界的开山鼻祖，的确是支持的最完善的一个了(当然得花钱)</li>
  <li>开启很迅速，同时在通过一大堆的设置之后，也能做到每次打开的页面都很干净</li>
  <li>我的四大要求基本上都能满足，嗯，所以我现在用的最多的也是这个。兜兜转转又回到了原点了</li>
  <li>这个软件还有一个好处是可以和chrome的adobe pdf插件配合使用，可以储存一些pdf在adobe的云端，同步比较方便</li>
</ul>]]></content><author><name>Wilson ZOU</name></author><category term="tech" /><summary type="html"><![CDATA[前言 pdf阅读器对我来说是非常重要的学习工具，但同时它也仅仅是一个学习工具。对我来说，它的大部分使用场景都是读paper或者是读课件读textbook，白嫖惯了不怎么有买纸质书的习惯。我也有ipad，但是notability用来记笔记我的字太丑，加上每次强迫症画条直线都要半天，标注结束都忘记自己要干嘛了。因此，我对pdf阅读器的要求主要集中在阅读体验和标注的便捷上，对于其他编辑pdf的功能，我暂时并不需要。在大学四年的学习中，我使用过许多的pdf浏览器，在此我把他们的最新版本都重新下载了一遍，也算是重温旧梦吧^_^ 正文 1. BookxNote Pro Screenshot from BookxNote Pro 非常干净的一款pdf阅读器，集成了一个markdown笔记本，同时支持脑图、大纲等功能（可惜我不太喜欢用） 我对pdf浏览器的一大要求就是文本的占比高，最好能把左右的工具栏页面等等隐藏起来，这款就符合我的要求 这个reader的工具也基本满足所有需求，同时滑动非常流畅，体验非常丝滑，也没有要登录或者升级的弹窗或者广告 我用电脑看pdf的另一个要求就是操作越少越好，像是高亮和划线，我希望一旦选中文字，工具框就能跳出来，这样从选中到高亮只需要一次操作，能让我更加专注于文字本身 这个浏览器还有四种颜色主题，暖色、黑夜模式和护眼模式，我都觉得很漂亮舒适 写到这完全想不起来自己当时放弃这个pdf浏览器的理由了，可能刚更新2.0所以我之前不喜欢的地方被改正了？让我再用用看…… 2. Xodo PDF Reader Screenshot from Xodo 我用的时间最长的PDF浏览器了，可以说它塑造了我对这类软件的偏好：非常现代好看的UI，非常便捷简单的标注，同时几乎隐藏所有工具状态栏的zen mode，支持护眼模式。重复一遍，这四点是我个人对pdf浏览器最重要的四个需求 从图片就可以看出来了，只用最上面薄薄的一个框，内容占比高的惊人，标注也是选中文字就可以点一下要高亮还是下划线了 xodo还多一个波浪线呢….嘛，虽然可能很多人觉得我在尬吹，但是做笔记的时候多个花纹还是好的呀 xodo支持一些pdf的其他操作，像是merge，split， remove password等等，但是是付费版的功能，而且我真的只是用来看书看论文，所以还是免了 这一款的滑动也是很丝滑的，嗯，一直重复这一点就是为了diss adobe acrobat，不知道是我自己的设置问题还是它就是有问题 放弃它的最主要原因，是启动速度太慢了，同样开一个文件，别的所有浏览器都是一瞬间，只有这一款每次都需要loading好一会儿，并且偶尔还会出现死机闪退的现象，不知道是我个人情况还是真的软件本身问题。嗯，说不定代码内部一直有些问题吧… 另一个小问题，就是调整页面大小的时候没有fit to width， fit to page的选项，每次只能滑滚调节，强迫症每次看到最后一点白边简直百爪挠心 3. Microsoft Edge浏览器 旧版edge永远滴神~~ 可惜更新了之后拉跨了不少。但作为windows原装的pdf浏览器，已经远超隔壁chrome重度残疾的pdf reader了 edge的滑动速度是最快的，同时想要打开文件的时候直接把文件往浏览器里拖就可以，对于可以用电脑的开卷考试，绝对能帮你最快找到答案 edge的另一个优点是可以用插件，嗯，说的就是saladict，看英文书的时候查单词特别方便 可惜毕竟主要是浏览器而不是pdf阅读器，很多功能还是缺失或者有瑕疵。像是没有颜色主题切换，而且标注的时候，选中 -&gt; 移到高亮 -&gt; 点击颜色，中间多了一个过程。我强迫症，我受不了，哼。 且不能插入文本框，有时候写一些自己的总结，或者上课做笔记还是不太方便 4. Foxit PDF Reader (福昕) 大一的时候使用的pdf浏览器，后来就被旧版edge和ipad给替代了，直到换了新的电脑，就彻底的被遗弃了。今天特地下回来再次体验一下。 现代化的UI，配色和icon都非常讨人喜欢 支持非常多的功能，对于想要追求大而全的用户应该很好吧，有点像office全家桶的感觉，工具栏的排布等等 在read mode的情况下只会剩下边框加上file home的那一栏，也是不错的，但是很多时候会看到右上角忽闪忽闪的广告，有点恼人 我最需要的标注功能上，选择只有复制和高亮两个，比起前几位就有些少了，不知道是不是能自己手动添加一些 滚动相对没有这么丝滑，不过我个人最不喜欢的还是太多的功能键会干扰我的思维，尤其是读不进论文的时候，更是会无意义的乱点按钮，这种时候界面越简单越沉得下心 5. PDF X-Change Editor 好吧其实这是一个editor不是reader了，放在这里和其他的比不太公平，但是这是一个免费的强大的pdf editor，所以还是记一下，将来说不定有用 安装起来毫不流氓，UI也不是10年前的古董graphic设计 6. Adobe Acrobat PDF pdf界的开山鼻祖，的确是支持的最完善的一个了(当然得花钱) 开启很迅速，同时在通过一大堆的设置之后，也能做到每次打开的页面都很干净 我的四大要求基本上都能满足，嗯，所以我现在用的最多的也是这个。兜兜转转又回到了原点了 这个软件还有一个好处是可以和chrome的adobe pdf插件配合使用，可以储存一些pdf在adobe的云端，同步比较方便]]></summary></entry><entry><title type="html">automatic cat feeder</title><link href="https://yzouag.github.io/project/automatic-cat-feeder/" rel="alternate" type="text/html" title="automatic cat feeder" /><published>2020-11-15T00:00:00+00:00</published><updated>2020-11-15T00:00:00+00:00</updated><id>https://yzouag.github.io/project/automatic-cat-feeder</id><content type="html" xml:base="https://yzouag.github.io/project/automatic-cat-feeder/"><![CDATA[<p>The automatic cat feeder is the project I done for my embeded system design course.</p>]]></content><author><name>Wilson ZOU</name></author><category term="project" /><summary type="html"><![CDATA[The automatic cat feeder is the project I done for my embeded system design course.]]></summary></entry><entry><title type="html">Software Engineering course project</title><link href="https://yzouag.github.io/project/javaFX-project/" rel="alternate" type="text/html" title="Software Engineering course project" /><published>2020-11-14T00:00:00+00:00</published><updated>2020-11-14T00:00:00+00:00</updated><id>https://yzouag.github.io/project/javaFX-project</id><content type="html" xml:base="https://yzouag.github.io/project/javaFX-project/"><![CDATA[<p>This is my project for software engineering. We use Java and JavaFX to build an application.</p>]]></content><author><name>Wilson ZOU</name></author><category term="project" /><summary type="html"><![CDATA[This is my project for software engineering. We use Java and JavaFX to build an application.]]></summary></entry><entry><title type="html">Generative Advererial Model</title><link href="https://yzouag.github.io/cs/gan-review/" rel="alternate" type="text/html" title="Generative Advererial Model" /><published>2020-10-01T00:00:00+00:00</published><updated>2020-10-01T00:00:00+00:00</updated><id>https://yzouag.github.io/cs/gan-review</id><content type="html" xml:base="https://yzouag.github.io/cs/gan-review/"><![CDATA[<p>This part will put my summary about GAN.</p>]]></content><author><name>Wilson ZOU</name></author><category term="cs" /><summary type="html"><![CDATA[This part will put my summary about GAN.]]></summary></entry><entry><title type="html">test</title><link href="https://yzouag.github.io/tech/java/" rel="alternate" type="text/html" title="test" /><published>2017-07-07T00:00:00+00:00</published><updated>2017-07-07T00:00:00+00:00</updated><id>https://yzouag.github.io/tech/java</id><content type="html" xml:base="https://yzouag.github.io/tech/java/"><![CDATA[<p>can you see me?</p>]]></content><author><name>Wilson ZOU</name></author><category term="tech" /><summary type="html"><![CDATA[can you see me?]]></summary></entry></feed>